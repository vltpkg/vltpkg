---
description: Breadth-first dependency graph building with peer context management
globs: src/graph/src/ideal/append-nodes.ts,src/graph/src/ideal/refresh-ideal-graph.ts,src/graph/src/ideal/types.ts
alwaysApply: false
---
# Graph Ideal Append Nodes Architecture

Detailed guide for understanding and working with the `append-nodes.ts` module in `@vltpkg/graph`, which implements breadth-first dependency graph building with deterministic ordering and peer dependency context management.

<rule>
name: graph_ideal_append_nodes
description: Architecture and implementation guide for the append-nodes module that builds dependency graphs in breadth-first order with peer context handling
filters:
  # Target the append-nodes module specifically
  - type: path
    pattern: "^src/graph/src/ideal/append-nodes\\.ts$"
  # Target files that import or use appendNodes
  - type: content
    pattern: "import.*appendNodes|from.*append-nodes"
  # Target files working with graph ideal building
  - type: path
    pattern: "^src/graph/src/ideal/"
  # Target peer context related content
  - type: content
    pattern: "peerContext|peerSetHash|startPeerPlacement|endPeerPlacement|postPlacementPeerCheck"

actions:
  - type: guide
    message: |
      ## Overview

      The `append-nodes.ts` module implements the core dependency graph building logic for the Ideal Graph construction phase. It processes dependencies in **breadth-first order** with **deterministic ordering** to ensure reproducible graph builds, while managing **peer dependency contexts** to handle version conflicts.

      ### Key Responsibilities
      - Fetch manifests for dependencies in parallel
      - Place nodes in the graph with proper edges
      - Handle modifiers, optional dependencies, and error conditions
      - Process child dependencies level by level
      - Maintain deterministic ordering for reproducible builds
      - **Manage peer dependency contexts** to handle incompatible peer versions
      - **Track and fork peer contexts** when version conflicts arise
      - **Resolve peer dependencies** using context-aware node lookup

      ðŸ“‹ **See `@graph/peers.mdc`** for detailed peer dependency isolation and `peerSetHash` mechanisms

  - type: architecture_guide
    message: |
      ## Core Architecture

      The module uses a **3-phase approach** for breadth-first processing with integrated peer context management:

      ### Phase 1: Manifest Fetching (`fetchManifestsForDeps`)
      ```typescript
      // Fetches manifests for all dependencies at a level in parallel
      const placementTasks = await fetchManifestsForDeps(
        packageInfo, graph, fromNode, sortedDeps, scurry, peerContext, modifierRefs, depth
      )
      ```
      - Processes existing node resolution via `graph.findResolution()`
      - **Checks peer edge compatibility** via `checkPeerEdgesCompatible()` before reusing nodes
      - **Candidate Fallback Loop**: If first satisfying node is peer-incompatible, tries other candidates deterministically
      - **Forks peer context** if existing node's peer edges are incompatible with new parent
      - Handles modifier spec swapping for edge modifiers
      - Fetches manifests in parallel using `Promise.all()`
      - Creates `ManifestFetchTask` and `NodePlacementTask` structures with peer context

      ### Phase 2: Node Placement (`processPlacementTasks`)
      ```typescript
      // Places nodes in the graph and collects child dependencies
      const childDepsToProcess = await processPlacementTasks(
        graph, options, placementTasks, add, modifiers, ...
      )
      ```
      - **Starts peer placement** via `startPeerPlacement()` to get `peerSetHash` and queued entries
      - Places nodes using `graph.placePackage()` with `joinExtra({ peerSetHash, modifier })`
      - Collects peer dependencies separately from regular dependencies (`nextPeerDeps`)
      - **Ends peer placement** via `endPeerPlacement()` returning context update functions
      - Handles optional dependency failures with `removeOptionalSubgraph()`

      ### Phase 3: Level Coordination (`appendNodes`)
      ```typescript
      // Orchestrates breadth-first processing across levels with peer context
      const [initialPeerContext] = graph.peerContexts
      let currentLevelDeps: AppendNodeEntry[] = [{ node, deps, peerContext: initialPeerContext, ... }]
      while (currentLevelDeps.length > 0) {
        const levelResults = await Promise.all(currentLevelDeps.map(...))
        // Post-placement peer check: fork contexts, resolve peer deps
        postPlacementPeerCheck(graph, levelResults)
        currentLevelDeps = nextLevelDeps
      }
      ```
      - Manages level-by-level processing queue with peer context propagation
      - **Performs post-placement peer check** via `postPlacementPeerCheck()` after each level
      - Ensures `seen` set consistency to prevent cycles
      - Maintains deterministic ordering with `spec.name.localeCompare()`

  - type: peer_integration_guide
    message: |
      ## Peer Dependency Integration

      The append-nodes module integrates tightly with the peer dependency system (`peers.ts`) through a 3-step workflow:

      ### Step 1: Pre-Placement Compatibility Check (`fetchManifestsForDeps`)
      ```typescript
      // Check if existing node's peer edges are compatible with new parent
      const peerCompatResult = existingNode ?
        checkPeerEdgesCompatible(existingNode, fromNode, peerContext, graph)
        : { compatible: true }

      // Fork peer context if incompatible peer edges detected
      if (!peerCompatResult.compatible && peerCompatResult.forkEntry) {
        effectivePeerContext = forkPeerContext(graph, peerContext, [peerCompatResult.forkEntry])
      }
      ```
      - Validates that reusing an existing node won't cause peer version conflicts
      - Returns `forkEntry` containing the conflicting spec and target when incompatible
      - Prevents incorrect node reuse that would break peer dependency contracts

      ### Step 2: Peer Placement Lifecycle (`processPlacementTasks`)
      ```typescript
      // START: Collect sibling deps and calculate peerSetHash
      const { peerSetHash, queuedEntries } = startPeerPlacement(
        peerContext, manifest, fromNode, options
      )

      // Place node with peer context hash
      const node = graph.placePackage(
        fromNode, type, spec, manifest, id,
        joinExtra({ peerSetHash, modifier: queryModifier })
      )

      // END: Get context update functions for post-processing
      const updateContext = endPeerPlacement(
        peerContext, nextDeps, nextPeerDeps, graph, spec, fromNode, node, type, queuedEntries
      )
      ```
      - `startPeerPlacement()`: Collects sibling dependencies, generates `peerSetHash` if manifest has peer deps
      - `endPeerPlacement()`: Returns `{ putEntries, resolvePeerDeps }` functions for deferred execution

      ### Step 3: Post-Level Peer Resolution (`appendNodes`)
      ```typescript
      // After processing all placement tasks at a level
      postPlacementPeerCheck(graph, levelResults)
      ```
      - Calls `putEntries()` on all children to update peer contexts
      - Detects which children need forked contexts and creates them
      - Reuses sibling contexts when compatible (avoids unnecessary forking)
      - Calls `resolvePeerDeps()` to resolve peer deps from context or add to next level

      ðŸ“‹ **See `@graph/peers.mdc`** for `PeerContext`, `PeerContextEntry`, and forking algorithms

  - type: data_structures_guide
    message: |
      ## Key Data Structures

      ### `AppendNodeEntry` (defined in `types.ts`)
      ```typescript
      type AppendNodeEntry = {
        node: Node                  // The node whose dependencies to process
        deps: Dependency[]          // Dependencies to fetch and place
        modifierRefs?: Map<string, ModifierActiveEntry>  // Active modifiers
        depth: number               // Current processing depth
        peerContext: PeerContext    // Current peer dependency context
        updateContext: {            // Peer context update functions
          putEntries: () => PeerContextEntryInput[] | undefined  // Add to context, return entries if fork needed
          resolvePeerDeps: () => void  // Resolve peer deps from context
        }
      }
      ```

      ### `ManifestFetchTask`
      ```typescript
      type ManifestFetchTask = {
        spec: Spec                                    // Dependency spec
        type: DependencySaveType                      // Dependency type (prod, dev, etc.)
        fromNode: Node                                // Parent node
        fileTypeInfo?: FileTypeInfo                   // File spec info
        activeModifier?: ModifierActiveEntry          // Active modifier
        queryModifier?: string                        // Modifier query
        edgeOptional: boolean                         // Is optional dependency
        manifestPromise: Promise<Manifest | undefined> // Async manifest fetch
        depth: number                                 // Processing depth
        peerContext: PeerContext                      // Peer context for this fetch
      }
      ```

      ### `NodePlacementTask`
      ```typescript
      type NodePlacementTask = {
        fetchTask: ManifestFetchTask      // Original fetch context
        manifest: Manifest | undefined    // Resolved manifest
        node?: Node                       // Created node (set during processing)
        childDeps?: Dependency[]          // Child dependencies to process
        childModifierRefs?: Map<string, ModifierActiveEntry> // Child modifier refs
        childPeerContext?: PeerContext    // Peer context for children
      }
      ```

      ### `PeerContext` (from `types.ts`)
      ```typescript
      type PeerContext = Map<string, PeerContextEntry> & {
        index?: number  // Unique index for peerSetHash generation
      }
      ```

  - type: processing_flow_guide
    message: |
      ## Processing Flow with Peer Context

      ### 1. Entry Point
      ```typescript
      appendNodes(packageInfo, graph, fromNode, deps, scurry, options, seen, add, modifiers, modifierRefs, ...)
      ```
      - **Input**: Node and its dependencies to process
      - **Output**: Fully built graph with all transitive dependencies and resolved peer contexts

      ### 2. Initial Peer Context Setup
      ```typescript
      // Get the initial peer context from the graph (main importer uses index 0)
      let initialPeerContext = graph.peerContexts[0]
      
      // WORKSPACE ISOLATION: Non-main importers get fresh peer contexts
      // This prevents cross-workspace peer leakage (e.g., root's react@18 affecting workspace's react@19)
      if (fromNode.importer && fromNode !== graph.mainImporter) {
        const nextPeerContext: PeerContext = new Map()
        nextPeerContext.index = graph.nextPeerContextIndex()
        graph.peerContexts[nextPeerContext.index] = nextPeerContext
        initialPeerContext = nextPeerContext
      }
      
      let currentLevelDeps: AppendNodeEntry[] = [{
        node: fromNode,
        deps,
        modifierRefs,
        depth: 0,
        peerContext: initialPeerContext,
        updateContext: { putEntries: () => undefined, resolvePeerDeps: () => {} }
      }]
      ```

      ### 3. Level Processing Loop with Peer Context
      ```typescript
      while (currentLevelDeps.length > 0) {
        // Step 3a: Process all nodes at current level in parallel
        const levelResults = await Promise.all(currentLevelDeps.map(async ({ node, deps, peerContext, ... }) => {
          seen.add(node.id)

          // Step 3b: Fetch manifests with peer compatibility checks
          const placementTasks = await fetchManifestsForDeps(
            packageInfo, graph, node, sortedDeps, scurry, peerContext, ...
          )

          // Step 3c: Place nodes with peer context, collect updateContext functions
          return await processPlacementTasks(graph, options, placementTasks, ...)
        }))

        // Step 3d: Post-placement peer check - fork contexts, resolve peer deps
        postPlacementPeerCheck(graph, levelResults)

        // Step 3e: Collect child dependencies with updated peer contexts
        currentLevelDeps = collectChildDependencies(levelResults)
      }
      ```

      ### 4. Peer Context Flow Diagram
      ```
      Initial Context (index: 0)
             â”‚
             â–¼
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ Level N Processing                      â”‚
      â”‚  - fetchManifestsForDeps()              â”‚
      â”‚    â””â”€ checkPeerEdgesCompatible()        â”‚
      â”‚  - processPlacementTasks()              â”‚
      â”‚    â”œâ”€ startPeerPlacement() â†’ peerSetHashâ”‚
      â”‚    â””â”€ endPeerPlacement() â†’ updateContextâ”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
             â–¼
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ postPlacementPeerCheck()                â”‚
      â”‚  - putEntries() for each child          â”‚
      â”‚  - forkPeerContext() if conflicts       â”‚
      â”‚  - resolvePeerDeps() from context       â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
             â–¼
      Child nodes with updated peer contexts
             â”‚
             â–¼
      Level N+1 Processing (repeat)
      ```

  - type: error_handling_guide
    message: |
      ## Error Handling Patterns

      ### Optional Dependency Failures
      ```typescript
      if (!manifest) {
        if (!edgeOptional && fromNode.isOptional()) {
          // Remove the entire optional subgraph
          removeOptionalSubgraph(graph, fromNode)
          continue
        } else if (edgeOptional) {
          // Ignore failed optional deps
          continue
        } else {
          // Hard failure for required dependencies
          throw error('failed to resolve dependency', { spec, from: fromNode.location })
        }
      }
      ```

      ### Cycle Prevention
      ```typescript
      // Mark nodes as seen when processing starts (not when complete)
      seen.add(node.id)

      // Check before adding to next level
      if (!seen.has(childDep.node.id)) {
        nextLevelDeps.push(childDep)
      }
      ```

      ### Peer Dependency Node Reuse Validation
      ```typescript
      // Defines what nodes are eligible to be reused
      const validExistingNode =
        existingNode &&
        !existingNode.detached &&
        // Regular deps can always reuse.
        // Peer deps can reuse as well if their peer edges are compatible.
        // (Avoids needless cloning like @isaacs/peer-dep-cycle-a@1.0.0Â·á¹—:*.)
        (!peer || peerCompatResult.compatible) &&
        // Check peer edge compatibility
        peerCompatResult.compatible
      ```

      ### Candidate Fallback for Peer-Incompatible Nodes
      ```typescript
      // If first candidate is peer-incompatible, try other candidates deterministically
      if (existingNode && !peerCompatResult.compatible && candidates && candidates.size > 1) {
        for (const candidate of candidates) {
          if (candidate === existingNode) continue  // Skip already checked
          if (candidate.detached) continue          // Skip stale nodes
          if (!satisfies(candidate.id, spec.final, ...)) continue  // Skip non-satisfying
          
          const compat = checkPeerEdgesCompatible(candidate, fromNode, peerContext, graph)
          if (compat.compatible) {
            existingNode = candidate
            peerCompatResult = compat
            break
          }
        }
      }
      ```
      This is crucial for multi-workspace scenarios where different workspaces may need different peer contexts.

      ### Nameless Dependencies
      ```typescript
      // Handle specs like 'github:foo/bar' that don't specify a name
      spec = fixupAddedNames(additiveMap, manifest, options, spec)
      ```

  - type: modifier_integration_guide
    message: |
      ## Modifier System Integration

      ### Spec Swapping
      ```typescript
      // Check if a modifier should replace the spec
      const queryModifier = activeModifier?.modifier.query
      const completeModifier = activeModifier?.interactiveBreadcrumb.current ===
                               activeModifier.modifier.breadcrumb.last

      if (queryModifier && completeModifier && 'spec' in activeModifier.modifier) {
        spec = activeModifier.modifier.spec
        if (spec.bareSpec === '-') {
          continue  // Skip this dependency
        }
      }
      ```

      ### Modifier and Peer Context Combined
      ```typescript
      // Both modifier query and peerSetHash are combined in the extra parameter
      const node = graph.placePackage(
        fromNode,
        type,
        spec,
        normalizeManifest(manifest),
        fileTypeInfo?.id,
        joinExtra({ peerSetHash, modifier: queryModifier })  // Combined extra
      )
      ```

      ### Modifier Updates
      ```typescript
      // Update modifier state after node placement
      if (activeModifier) {
        modifiers?.updateActiveEntry(node, activeModifier)
      }

      // Generate modifier refs for child dependencies
      childModifierRefs = modifiers?.tryDependencies(node, nextDeps)
      ```

  - type: performance_optimization_guide
    message: |
      ## Performance Characteristics

      ### Parallel Processing
      - **Level Parallelism**: All nodes at the same depth processed simultaneously
      - **Manifest Fetching**: All manifests for a level fetched in parallel
      - **I/O Batching**: Reduces network round trips compared to depth-first

      ### Memory Efficiency
      - **Streaming Processing**: Processes level by level, not all at once
      - **Seen Set**: Prevents duplicate processing and infinite cycles
      - **Shared References**: Reuses existing nodes via `graph.findResolution()`
      - **Peer Context Reuse**: Attempts to reuse sibling peer contexts before forking

      ### Deterministic Ordering
      - **Reproducible Builds**: Same input always produces same graph structure
      - **Consistent Output**: Sorting by `spec.name` ensures predictable order
      - **Sorted Peer Context Processing**: `postPlacementPeerCheck` sorts by `node.id` for determinism
      - **Debug Friendly**: Deterministic processing aids in debugging

      ### Early Extraction
      - Eligible nodes can be extracted to vlt store during graph building
      - Extraction happens in parallel with graph construction
      - Skips peer dependencies and optional dependencies for extraction

  - type: integration_patterns
    message: |
      ## Integration with Graph System

      ### Used By
      - `src/graph/src/ideal/refresh-ideal-graph.ts` - High-level dependency resolution, exports `nextPeerContextIndex()`
      - `src/graph/src/ideal/build-ideal-from-starting-graph.ts` - Ideal graph construction

      ### Dependencies from `peers.ts`
      - `checkPeerEdgesCompatible()` - Validate existing node peer compatibility
      - `forkPeerContext()` - Create new peer context when conflicts arise
      - `startPeerPlacement()` - Begin peer placement, get peerSetHash and queued entries
      - `endPeerPlacement()` - End peer placement, get updateContext functions
      - `postPlacementPeerCheck()` - Post-level peer context updates and resolution

      ### Dependencies from Graph Core
      - `graph.findResolution()` - Find existing satisfying nodes
      - `graph.placePackage()` - Place new nodes with edges and extra (modifier + peerSetHash)
      - `graph.addEdge()` - Create edges to existing nodes
      - `graph.peerContexts` - Array of peer contexts tracked by the graph
      - `graph.nextPeerContextIndex()` - Get next unique peer context index

      ### Dependencies from Other Modules
      - `removeOptionalSubgraph()` - Handle optional failures
      - `joinExtra()` - Combine modifier and peerSetHash into extra parameter
      - `fixupAddedNames()` - Handle nameless dependencies

      ### Data Flow
      ```
      refresh-ideal-graph.ts
             â”‚
             â–¼
      appendNodes() â”€â”€â”¬â”€â”€â–º fetchManifestsForDeps()
                      â”‚         â”‚
                      â”‚         â”œâ”€â–º checkPeerEdgesCompatible()
                      â”‚         â””â”€â–º forkPeerContext() (if needed)
                      â”‚
                      â”œâ”€â”€â–º processPlacementTasks()
                      â”‚         â”‚
                      â”‚         â”œâ”€â–º startPeerPlacement()
                      â”‚         â”œâ”€â–º graph.placePackage()
                      â”‚         â””â”€â–º endPeerPlacement()
                      â”‚
                      â””â”€â”€â–º postPlacementPeerCheck()
                                â”‚
                                â”œâ”€â–º putEntries()
                                â”œâ”€â–º forkPeerContext() (if needed)
                                â””â”€â–º resolvePeerDeps()
      ```

  - type: testing_considerations
    message: |
      ## Testing and Debugging

      ### Test Coverage Requirements
      - **100% Coverage**: All paths must be tested including error conditions
      - **Edge Cases**: Optional failures, cycles, nameless deps, modifiers
      - **Peer Context Cases**: Context forking, peerSetHash generation, peer resolution
      - **Deterministic Output**: Tests verify consistent ordering

      ### Peer-Related Test Cases
      1. **Peer Edge Compatibility**: Test `checkPeerEdgesCompatible()` with compatible/incompatible scenarios
      2. **Context Forking**: Verify `forkPeerContext()` creates isolated contexts
      3. **PeerSetHash Assignment**: Confirm nodes with peer deps get correct peerSetHash
      4. **Sibling Context Reuse**: Test that compatible siblings share peer contexts
      5. **Peer Resolution from Context**: Verify peer deps resolve from context when satisfied
      6. **Candidate Fallback**: Test that peer-incompatible first candidates trigger fallback loop
      7. **Workspace Isolation**: Verify non-main importers get fresh peer contexts
      8. **Fork Cache**: Test that `graph.peerContextForkCache` prevents duplicate contexts

      ### Common Issues
      1. **Cycle Detection**: Ensure `seen` set is managed correctly
      2. **Optional Handling**: Verify optional subgraph removal works
      3. **Manifest Errors**: Test both network and parsing failures
      4. **Modifier State**: Ensure modifiers are updated correctly
      5. **Peer Context Leaks**: Verify forked contexts don't affect parent contexts

      ### Debugging Tips
      - Check `seen` set state for cycle issues
      - Verify deterministic ordering with different input orders
      - Trace level-by-level processing for dependency issues
      - Monitor `graph.nodes` and `graph.edges` growth
      - Inspect `graph.peerContexts` array for context forking behavior
      - Check `node.peerSetHash` values to trace peer context assignments
      - Check `graph.peerContextForkCache` size for fork efficiency
      - Verify `graph.peerContexts.length > 1` for multi-workspace isolation

examples:
  - input: |
      // Example: Adding a new dependency with peer context awareness
      await appendNodes(
        packageInfo,         // manifest fetcher
        graph,               // target graph
        importerNode,        // starting node
        [{ spec: reactDomSpec, type: 'prod' }], // dependencies
        scurry,              // path resolver
        options,             // spec options
        new Set(),           // seen set
        add,                 // add map
        modifiers,           // modifier system
        modifierRefs,        // active modifier refs
        extractPromises,     // early extraction promises
        actual,              // actual graph for extraction
        seenExtracted,       // extraction tracking set
        remover,             // rollback remover
        transientAdd,        // transient additions
        transientRemove      // transient removals
      )
    output: "Breadth-first processing with peer context management and early extraction"

  - input: |
      // Example: Processing with peer context lifecycle
      // In fetchManifestsForDeps:
      const peerCompatResult = checkPeerEdgesCompatible(existingNode, fromNode, peerContext, graph)
      if (!peerCompatResult.compatible) {
        effectivePeerContext = forkPeerContext(graph, peerContext, [peerCompatResult.forkEntry])
      }

      // In processPlacementTasks:
      const { peerSetHash, queuedEntries } = startPeerPlacement(peerContext, manifest, fromNode, options)
      const node = graph.placePackage(fromNode, type, spec, manifest, id, joinExtra({ peerSetHash, modifier }))
      const updateContext = endPeerPlacement(peerContext, nextDeps, nextPeerDeps, graph, spec, fromNode, node, type, queuedEntries)

      // In appendNodes main loop:
      postPlacementPeerCheck(graph, levelResults)
    output: "Complete peer context lifecycle from compatibility check through resolution"

  - input: |
      // Example: Post-placement peer check with context forking
      // From postPlacementPeerCheck in peers.ts
      for (const childDep of sortedChildDeps) {
        const needsFork = childDep.updateContext.putEntries()
        if (needsFork) {
          needsForking.set(childDep, needsFork)
        }
      }

      for (const [childDep, nextEntries] of sortedNeedsForkingEntries) {
        if (prevContext && !checkEntriesToPeerContext(prevContext, nextEntries)) {
          // Reuse sibling's context
          childDep.peerContext = prevContext
        } else {
          // Fork new context
          childDep.peerContext = forkPeerContext(graph, childDep.peerContext, nextEntries)
          prevContext = childDep.peerContext
        }
      }

      for (const childDep of sortedChildDeps) {
        childDep.updateContext.resolvePeerDeps()
      }
    output: "Post-placement peer context forking and resolution with sibling context reuse"

  - input: |
      // Example: Testing workspace peer context isolation
      // Each workspace importer should get its own peer context
      const mainReactEdge = graph.mainImporter.edgesOut.get('react')
      const wsReactEdge = wsImporter.edgesOut.get('react')
      
      t.equal(mainReactEdge?.to?.version, '18.3.1', 'main importer should have react@18')
      t.equal(wsReactEdge?.to?.version, '19.2.0', 'workspace importer should have react@19')
      t.ok(graph.peerContexts.length > 1, 'should have multiple peer contexts for isolation')
    output: "Verified workspace peer context isolation prevents cross-workspace leakage"

  - input: |
      // Example: Candidate fallback when first satisfying node is peer-incompatible
      // Setup: multiple foo candidates with different peer targets
      const peerContext = graph.peerContexts[0]
      peerContext.set('react', { target: react183, ... })  // Context expects react@18.3
      
      // foo@1.0.0 has peer edge to react@18.2 (incompatible)
      // foo@1.0.2 has peer edge to react@18.3 (compatible)
      await appendNodes(packageInfo, graph, mainImporter, [fooDep], ...)
      
      const edge = graph.mainImporter.edgesOut.get('foo')
      t.equal(edge?.to?.id, foo102.id, 'should skip incompatible foo@1.0.0, use foo@1.0.2')
    output: "Candidate fallback selects peer-compatible node over first satisfying node"

metadata:
  priority: high
  version: 2.1
  tags:
    - graph
    - ideal
    - append-nodes
    - breadth-first
    - dependencies
    - modifiers
    - deterministic
    - parallel
    - peer-dependencies
    - peer-context
  related_rules:
    - graph_data_structure
    - graph_ideal
    - graph_modifiers
    - graph_peers
    - graph_lockfiles
    - monorepo_structure
</rule>
