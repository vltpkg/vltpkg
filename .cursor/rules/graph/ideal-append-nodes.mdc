---
description: Breadth-first dependency graph building with peer context management
globs: src/graph/src/ideal/append-nodes.ts,src/graph/src/ideal/refresh-ideal-graph.ts,src/graph/src/ideal/types.ts
alwaysApply: false
---
# Graph Ideal Append Nodes Architecture

Detailed guide for understanding and working with the `append-nodes.ts` module in `@vltpkg/graph`, which implements breadth-first dependency graph building with deterministic ordering and peer dependency context management.

<rule>
name: graph_ideal_append_nodes
description: Architecture and implementation guide for the append-nodes module that builds dependency graphs in breadth-first order with peer context handling
filters:
  # Target the append-nodes module specifically
  - type: path
    pattern: "^src/graph/src/ideal/append-nodes\\.ts$"
  # Target files that import or use appendNodes
  - type: content
    pattern: "import.*appendNodes|from.*append-nodes"
  # Target files working with graph ideal building
  - type: path
    pattern: "^src/graph/src/ideal/"
  # Target peer context related content
  - type: content
    pattern: "peerContext|peerSetHash|startPeerPlacement|endPeerPlacement|postPlacementPeerCheck"

actions:
  - type: guide
    message: |
      ## Overview

      The `append-nodes.ts` module implements the core dependency graph building logic for the Ideal Graph construction phase. It processes dependencies in **breadth-first order** with **deterministic ordering** to ensure reproducible graph builds, while managing **peer dependency contexts** to handle version conflicts.

      ### Key Responsibilities
      - Fetch manifests for dependencies in parallel
      - Place nodes in the graph with proper edges
      - Handle modifiers, optional dependencies, and error conditions
      - Process child dependencies level by level
      - Maintain deterministic ordering for reproducible builds
      - **Manage peer dependency contexts** to handle incompatible peer versions
      - **Track and fork peer contexts** when version conflicts arise
      - **Resolve peer dependencies** using context-aware node lookup

      ðŸ“‹ **See `@graph/peers.mdc`** for detailed peer dependency isolation and `peerSetHash` mechanisms

  - type: architecture_guide
    message: |
      ## Core Architecture

      The module uses a **3-phase BFS loop** for deterministic graph building:

      ### PHASE A: PARALLEL FETCH (READ-ONLY)
      ```typescript
      // Fetches manifests without mutating the graph
      const fetchResults = await Promise.all(
        currentLevelDeps.map(async ({ node, deps, peerContext, ... }) => {
          const result = await fetchManifestsForDeps(
            packageInfo, graph, node, sortedDeps, scurry, peerContext, modifierRefs, depth
          )
          return { entry, result }  // result: { placementTasks, reuseTasks, forkRequests }
        })
      )
      ```
      - **Read-only**: No graph mutations during parallel fetch
      - Returns `FetchResult` with deferred tasks instead of immediately applying changes
      - `reuseTasks`: Deferred edge creation for existing node reuse
      - `forkRequests`: Accumulated peer context fork entries
      - Prevents race conditions from network timing variations

      ### PHASE B: SERIAL MUTATIONS (DETERMINISTIC ORDER)
      ```typescript
      // Sort by stable identifiers for deterministic ordering
      const sortedResults = fetchResults.sort((a, b) => {
        const keyA = `${a.entry.node.id}::${a.entry.depth}`
        const keyB = `${b.entry.node.id}::${b.entry.depth}`
        return keyA.localeCompare(keyB, 'en')
      })

      // Apply mutations serially
      for (const { entry, result } of sortedResults) {
        // 1. Apply accumulated fork requests
        if (result.forkRequests.length > 0) {
          entry.peerContext = forkPeerContext(graph, entry.peerContext, result.forkRequests)
        }
        // 2. Apply reuse edges in sorted order
        for (const { type, spec, fromNode, toNode } of sortedReuseTasks) {
          graph.addEdge(type, spec, fromNode, toNode)
        }
        // 3. Place nodes and collect child deps
        const placed = await processPlacementTasks(graph, options, result.placementTasks, ...)
        levelResults.push(placed)
      }
      ```
      - Sorts results by DepID-based keys for stability
      - Applies all mutations in deterministic order regardless of fetch completion order

      ### PHASE C: POST-PLACEMENT PEER CHECK
      ```typescript
      postPlacementPeerCheck(graph, levelResults)
      ```
      - Calls `putEntries()` on all children to update peer contexts
      - Forks contexts when conflicts detected, reuses sibling contexts when compatible
      - Calls `resolvePeerDeps()` to resolve peer deps from context

      ### Helper Functions
      - `fetchManifestsForDeps()`: **Read-only** manifest fetching, returns `FetchResult`
      - `processPlacementTasks()`: Serial node placement with peer lifecycle

  - type: peer_integration_guide
    message: |
      ## Peer Dependency Integration

      The append-nodes module integrates tightly with the peer dependency system (`peers.ts`) through a 3-step workflow:

      ### Step 1: Pre-Placement Compatibility Check (`fetchManifestsForDeps`)
      ```typescript
      // Check if existing node's peer edges are compatible with new parent
      const peerCompatResult = existingNode ?
        checkPeerEdgesCompatible(existingNode, fromNode, peerContext, graph)
        : { compatible: true }

      // Accumulate fork request (deferred - applied in Phase B)
      if (!peerCompatResult.compatible && peerCompatResult.forkEntry) {
        forkRequests.push(peerCompatResult.forkEntry)
        // Fork will be applied together with other fork requests from this fromNode
      }
      ```
      - Validates that reusing an existing node won't cause peer version conflicts
      - Returns `forkEntry` containing the conflicting spec and target when incompatible
      - **Deferred**: Fork requests are accumulated, not applied immediately (read-only phase)
      - Prevents incorrect node reuse that would break peer dependency contracts

      ### Step 2: Peer Placement Lifecycle (`processPlacementTasks`)
      ```typescript
      // START: Collect sibling deps and calculate peerSetHash
      const { peerSetHash, queuedEntries } = startPeerPlacement(
        peerContext, manifest, fromNode, options
      )

      // Place node with peer context hash
      const node = graph.placePackage(
        fromNode, type, spec, manifest, id,
        joinExtra({ peerSetHash, modifier: queryModifier })
      )

      // END: Get context update functions for post-processing
      const updateContext = endPeerPlacement(
        peerContext, nextDeps, nextPeerDeps, graph, spec, fromNode, node, type, queuedEntries
      )
      ```
      - `startPeerPlacement()`: Collects sibling dependencies, generates `peerSetHash` if manifest has peer deps
      - `endPeerPlacement()`: Returns `{ putEntries, resolvePeerDeps }` functions for deferred execution

      ### Step 3: Post-Level Peer Resolution (`appendNodes`)
      ```typescript
      // After processing all placement tasks at a level
      postPlacementPeerCheck(graph, levelResults)
      ```
      - Calls `putEntries()` on all children to update peer contexts
      - Detects which children need forked contexts and creates them
      - Reuses sibling contexts when compatible (avoids unnecessary forking)
      - Calls `resolvePeerDeps()` to resolve peer deps from context or add to next level

      ðŸ“‹ **See `@graph/peers.mdc`** for `PeerContext`, `PeerContextEntry`, and forking algorithms

  - type: data_structures_guide
    message: |
      ## Key Data Structures

      ### `FetchResult` (returned by `fetchManifestsForDeps`)
      ```typescript
      type FetchResult = {
        placementTasks: NodePlacementTask[]  // Nodes to place
        reuseTasks: ReuseTask[]              // Deferred edge creation for existing nodes
        forkRequests: PeerContextEntryInput[] // Accumulated peer context fork entries
      }
      ```
      This structure enables read-only parallel fetching with deferred mutations.

      ### `ReuseTask` (deferred edge creation)
      ```typescript
      type ReuseTask = {
        type: DependencySaveType  // Edge type (prod, dev, etc.)
        spec: Spec                // Dependency spec
        fromNode: Node            // Parent node
        toNode: Node              // Existing node to reuse
      }
      ```
      Previously `graph.addEdge()` was called immediately during parallel fetch, causing
      non-determinism. Now edges are collected and applied serially in Phase B.

      ### `AppendNodeEntry` (defined in `types.ts`)
      ```typescript
      type AppendNodeEntry = {
        node: Node                  // The node whose dependencies to process
        deps: Dependency[]          // Dependencies to fetch and place
        modifierRefs?: Map<string, ModifierActiveEntry>  // Active modifiers
        depth: number               // Current processing depth
        peerContext: PeerContext    // Current peer dependency context
        updateContext: {            // Peer context update functions
          putEntries: () => PeerContextEntryInput[] | undefined  // Add to context, return entries if fork needed
          resolvePeerDeps: () => void  // Resolve peer deps from context
        }
      }
      ```

      ### `ManifestFetchTask`
      ```typescript
      type ManifestFetchTask = {
        spec: Spec                                    // Dependency spec
        type: DependencySaveType                      // Dependency type (prod, dev, etc.)
        fromNode: Node                                // Parent node
        fileTypeInfo?: FileTypeInfo                   // File spec info
        activeModifier?: ModifierActiveEntry          // Active modifier
        queryModifier?: string                        // Modifier query
        edgeOptional: boolean                         // Is optional dependency
        manifestPromise: Promise<Manifest | undefined> // Async manifest fetch
        depth: number                                 // Processing depth
        peerContext: PeerContext                      // Peer context for this fetch
      }
      ```

      ### `NodePlacementTask`
      ```typescript
      type NodePlacementTask = {
        fetchTask: ManifestFetchTask      // Original fetch context
        manifest: Manifest | undefined    // Resolved manifest
        node?: Node                       // Created node (set during processing)
        childDeps?: Dependency[]          // Child dependencies to process
        childModifierRefs?: Map<string, ModifierActiveEntry> // Child modifier refs
        childPeerContext?: PeerContext    // Peer context for children
      }
      ```

      ### `PeerContext` (from `types.ts`)
      ```typescript
      type PeerContext = Map<string, PeerContextEntry> & {
        index?: number  // Unique index for peerSetHash generation
      }
      ```

  - type: processing_flow_guide
    message: |
      ## Processing Flow with Peer Context

      ### 1. Entry Point
      ```typescript
      appendNodes(packageInfo, graph, fromNode, deps, scurry, options, seen, add, modifiers, modifierRefs, ...)
      ```
      - **Input**: Node and its dependencies to process
      - **Output**: Fully built graph with all transitive dependencies and resolved peer contexts

      ### 2. Initial Peer Context Setup
      ```typescript
      // Get the initial peer context from the graph (main importer uses index 0)
      let initialPeerContext = graph.peerContexts[0]
      
      // WORKSPACE ISOLATION: Non-main importers get fresh peer contexts
      // This prevents cross-workspace peer leakage (e.g., root's react@18 affecting workspace's react@19)
      if (fromNode.importer && fromNode !== graph.mainImporter) {
        const nextPeerContext: PeerContext = new Map()
        nextPeerContext.index = graph.nextPeerContextIndex()
        graph.peerContexts[nextPeerContext.index] = nextPeerContext
        initialPeerContext = nextPeerContext
      }
      
      let currentLevelDeps: AppendNodeEntry[] = [{
        node: fromNode,
        deps,
        modifierRefs,
        depth: 0,
        peerContext: initialPeerContext,
        updateContext: { putEntries: () => undefined, resolvePeerDeps: () => {} }
      }]
      ```

      ### 3. Level Processing Loop (3-Phase per Level)
      ```typescript
      while (currentLevelDeps.length > 0) {
        // ========== PHASE A: PARALLEL FETCH (READ-ONLY) ==========
        const fetchResults = await Promise.all(currentLevelDeps.map(async ({ node, deps, peerContext, ... }) => {
          seen.add(node.id)
          // Fetch manifests without mutating graph - returns FetchResult
          const result = await fetchManifestsForDeps(packageInfo, graph, node, sortedDeps, ...)
          return { entry: { node, deps, peerContext, ... }, result }
        }))

        // ========== PHASE B: SERIAL MUTATIONS (DETERMINISTIC) ==========
        // Sort by stable identifiers (DepID::depth)
        const sortedResults = fetchResults.sort((a, b) => 
          `${a.entry.node.id}::${a.entry.depth}`.localeCompare(`${b.entry.node.id}::${b.entry.depth}`, 'en')
        )

        const levelResults = []
        for (const { entry, result } of sortedResults) {
          // Apply fork requests, reuse edges, and place nodes serially
          if (result.forkRequests.length > 0) {
            entry.peerContext = forkPeerContext(graph, entry.peerContext, result.forkRequests)
          }
          for (const reuseTask of sortedReuseTasks) graph.addEdge(...)
          levelResults.push(await processPlacementTasks(...))
        }

        // ========== PHASE C: POST-PLACEMENT PEER CHECK ==========
        postPlacementPeerCheck(graph, levelResults)

        // Collect child dependencies for next level
        currentLevelDeps = collectChildDependencies(levelResults)
      }
      ```

      ### 4. Peer Context Flow Diagram (3-Phase Architecture)
      ```
      Initial Context (index: 0)
             â”‚
             â–¼
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ PHASE A: PARALLEL FETCH (READ-ONLY)     â”‚
      â”‚  - fetchManifestsForDeps() in parallel  â”‚
      â”‚    â”œâ”€ checkPeerEdgesCompatible()        â”‚
      â”‚    â”œâ”€ Accumulate forkRequests (deferred)â”‚
      â”‚    â””â”€ Accumulate reuseTasks (deferred)  â”‚
      â”‚  - Returns FetchResult per entry        â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
             â–¼
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ PHASE B: SERIAL MUTATIONS (DETERMINISTIC)â”‚
      â”‚  - Sort results by DepID::depth         â”‚
      â”‚  - For each (in order):                 â”‚
      â”‚    â”œâ”€ Apply forkRequests â†’ forkPeerContextâ”‚
      â”‚    â”œâ”€ Apply reuseTasks â†’ graph.addEdge  â”‚
      â”‚    â””â”€ processPlacementTasks()           â”‚
      â”‚        â”œâ”€ startPeerPlacement() â†’ hash   â”‚
      â”‚        â””â”€ endPeerPlacement() â†’ context  â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
             â–¼
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ PHASE C: POST-PLACEMENT PEER CHECK      â”‚
      â”‚  - putEntries() for each child          â”‚
      â”‚  - forkPeerContext() if conflicts       â”‚
      â”‚  - resolvePeerDeps() from context       â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
             â–¼
      Level N+1 Processing (repeat)
      ```

  - type: error_handling_guide
    message: |
      ## Error Handling Patterns

      ### Optional Dependency Failures
      ```typescript
      if (!manifest) {
        if (!edgeOptional && fromNode.isOptional()) {
          // Remove the entire optional subgraph
          removeOptionalSubgraph(graph, fromNode)
          continue
        } else if (edgeOptional) {
          // Ignore failed optional deps
          continue
        } else {
          // Hard failure for required dependencies
          throw error('failed to resolve dependency', { spec, from: fromNode.location })
        }
      }
      ```

      ### Cycle Prevention
      ```typescript
      // Mark nodes as seen when processing starts (not when complete)
      seen.add(node.id)

      // Check before adding to next level
      if (!seen.has(childDep.node.id)) {
        nextLevelDeps.push(childDep)
      }
      ```

      ### Peer Dependency Node Reuse Validation
      ```typescript
      // Defines what nodes are eligible to be reused
      const validExistingNode =
        existingNode &&
        !existingNode.detached &&
        // Regular deps can always reuse.
        // Peer deps can reuse as well if their peer edges are compatible.
        (!peer || peerCompatResult.compatible) &&
        // Check peer edge compatibility
        peerCompatResult.compatible
      ```
      **Note**: Reuse is deferred - `reuseTasks` are collected during Phase A and
      applied serially in Phase B for deterministic ordering.

      ### Candidate Fallback for Peer-Incompatible Nodes
      ```typescript
      // If first candidate is peer-incompatible, try other candidates deterministically
      if (existingNode && !peerCompatResult.compatible && candidates && candidates.size > 1) {
        for (const candidate of candidates) {
          if (candidate === existingNode) continue  // Skip already checked
          if (candidate.detached) continue          // Skip stale nodes
          if (!satisfies(candidate.id, spec.final, ...)) continue  // Skip non-satisfying
          
          const compat = checkPeerEdgesCompatible(candidate, fromNode, peerContext, graph)
          if (compat.compatible) {
            existingNode = candidate
            peerCompatResult = compat
            break
          }
        }
      }
      ```
      This is crucial for multi-workspace scenarios where different workspaces may need different peer contexts.

      ### Nameless Dependencies
      ```typescript
      // Handle specs like 'github:foo/bar' that don't specify a name
      spec = fixupAddedNames(additiveMap, manifest, options, spec)
      ```

  - type: modifier_integration_guide
    message: |
      ## Modifier System Integration

      ### Spec Swapping
      ```typescript
      // Check if a modifier should replace the spec
      const queryModifier = activeModifier?.modifier.query
      const completeModifier = activeModifier?.interactiveBreadcrumb.current ===
                               activeModifier.modifier.breadcrumb.last

      if (queryModifier && completeModifier && 'spec' in activeModifier.modifier) {
        spec = activeModifier.modifier.spec
        if (spec.bareSpec === '-') {
          continue  // Skip this dependency
        }
      }
      ```

      ### Modifier and Peer Context Combined
      ```typescript
      // Both modifier query and peerSetHash are combined in the extra parameter
      const node = graph.placePackage(
        fromNode,
        type,
        spec,
        normalizeManifest(manifest),
        fileTypeInfo?.id,
        joinExtra({ peerSetHash, modifier: queryModifier })  // Combined extra
      )
      ```

      ### Modifier Updates
      ```typescript
      // Update modifier state after node placement
      if (activeModifier) {
        modifiers?.updateActiveEntry(node, activeModifier)
      }

      // Generate modifier refs for child dependencies
      childModifierRefs = modifiers?.tryDependencies(node, nextDeps)
      ```

  - type: performance_optimization_guide
    message: |
      ## Performance Characteristics

      ### Parallel Processing
      - **Level Parallelism**: All nodes at the same depth processed simultaneously
      - **Manifest Fetching**: All manifests for a level fetched in parallel
      - **I/O Batching**: Reduces network round trips compared to depth-first

      ### Memory Efficiency
      - **Streaming Processing**: Processes level by level, not all at once
      - **Seen Set**: Prevents duplicate processing and infinite cycles
      - **Shared References**: Reuses existing nodes via `graph.findResolution()`
      - **Peer Context Reuse**: Attempts to reuse sibling peer contexts before forking

      ### Deterministic Ordering
      - **Reproducible Builds**: Same input always produces same graph structure
      - **Read-Only Fetch Phase**: No mutations during parallel network operations prevents timing-based non-determinism
      - **Stable Sorting Keys**: Results sorted by `DepID::depth` before applying mutations
      - **Deferred Edge Creation**: Reuse edges collected and applied in sorted order
      - **Sorted Peer Context Processing**: `postPlacementPeerCheck` sorts by `node.id` for determinism
      - **Debug Friendly**: Deterministic processing aids in debugging

      ### Early Extraction
      - Eligible nodes can be extracted to vlt store during graph building
      - Extraction happens in parallel with graph construction
      - Skips peer dependencies and optional dependencies for extraction

  - type: integration_patterns
    message: |
      ## Integration with Graph System

      ### Used By
      - `src/graph/src/ideal/refresh-ideal-graph.ts` - High-level dependency resolution
      - `src/graph/src/ideal/build-ideal-from-starting-graph.ts` - Ideal graph construction

      ### Dependencies from `peers.ts`
      - `checkPeerEdgesCompatible()` - Validate existing node peer compatibility
      - `forkPeerContext()` - Create new peer context when conflicts arise
      - `startPeerPlacement()` - Begin peer placement, get peerSetHash and queued entries
      - `endPeerPlacement()` - End peer placement, get updateContext functions
      - `postPlacementPeerCheck()` - Post-level peer context updates and resolution

      ### Dependencies from Graph Core
      - `graph.findResolution()` - Find existing satisfying nodes
      - `graph.placePackage()` - Place new nodes with edges and extra (modifier + peerSetHash)
      - `graph.addEdge()` - Create edges to existing nodes
      - `graph.peerContexts` - Array of peer contexts tracked by the graph
      - `graph.nextPeerContextIndex()` - Get next unique peer context index

      ### Dependencies from Other Modules
      - `removeOptionalSubgraph()` - Handle optional failures
      - `joinExtra()` - Combine modifier and peerSetHash into extra parameter
      - `fixupAddedNames()` - Handle nameless dependencies

      ### Data Flow
      ```
      refresh-ideal-graph.ts
             â”‚
             â–¼
      appendNodes()
             â”‚
      â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ PHASE A: PARALLEL FETCH (READ-ONLY)         â”‚
      â”‚  fetchManifestsForDeps() â†’ FetchResult      â”‚
      â”‚    â”œâ”€â–º checkPeerEdgesCompatible()           â”‚
      â”‚    â”œâ”€â–º Accumulate forkRequests              â”‚
      â”‚    â””â”€â–º Accumulate reuseTasks                â”‚
      â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
      â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ PHASE B: SERIAL MUTATIONS                   â”‚
      â”‚  Sort results by DepID::depth               â”‚
      â”‚    â”œâ”€â–º forkPeerContext() (apply forkRequests)â”‚
      â”‚    â”œâ”€â–º graph.addEdge() (apply reuseTasks)   â”‚
      â”‚    â””â”€â–º processPlacementTasks()              â”‚
      â”‚          â”œâ”€â–º startPeerPlacement()           â”‚
      â”‚          â”œâ”€â–º graph.placePackage()           â”‚
      â”‚          â””â”€â–º endPeerPlacement()             â”‚
      â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
      â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ PHASE C: POST-PLACEMENT                     â”‚
      â”‚  postPlacementPeerCheck()                   â”‚
      â”‚    â”œâ”€â–º putEntries()                         â”‚
      â”‚    â”œâ”€â–º forkPeerContext() (if conflicts)     â”‚
      â”‚    â””â”€â–º resolvePeerDeps()                    â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      ```

  - type: testing_considerations
    message: |
      ## Testing and Debugging

      ### Test Coverage Requirements
      - **100% Coverage**: All paths must be tested including error conditions
      - **Edge Cases**: Optional failures, cycles, nameless deps, modifiers
      - **Peer Context Cases**: Context forking, peerSetHash generation, peer resolution
      - **Deterministic Output**: Tests verify consistent ordering

      ### Peer-Related Test Cases
      1. **Peer Edge Compatibility**: Test `checkPeerEdgesCompatible()` with compatible/incompatible scenarios
      2. **Context Forking**: Verify `forkPeerContext()` creates isolated contexts
      3. **PeerSetHash Assignment**: Confirm nodes with peer deps get correct peerSetHash
      4. **Sibling Context Reuse**: Test that compatible siblings share peer contexts
      5. **Peer Resolution from Context**: Verify peer deps resolve from context when satisfied
      6. **Candidate Fallback**: Test that peer-incompatible first candidates trigger fallback loop
      7. **Workspace Isolation**: Verify non-main importers get fresh peer contexts
      8. **Fork Cache**: Test that `graph.peerContextForkCache` prevents duplicate contexts

      ### Common Issues
      1. **Cycle Detection**: Ensure `seen` set is managed correctly
      2. **Optional Handling**: Verify optional subgraph removal works
      3. **Manifest Errors**: Test both network and parsing failures
      4. **Modifier State**: Ensure modifiers are updated correctly
      5. **Peer Context Leaks**: Verify forked contexts don't affect parent contexts

      ### Debugging Tips
      - Check `seen` set state for cycle issues
      - Verify deterministic ordering with different input orders
      - Trace level-by-level processing for dependency issues
      - Monitor `graph.nodes` and `graph.edges` growth
      - Inspect `graph.peerContexts` array for context forking behavior
      - Check `node.peerSetHash` values to trace peer context assignments
      - Check `graph.peerContextForkCache` size for fork efficiency
      - Verify `graph.peerContexts.length > 1` for multi-workspace isolation

examples:
  - input: |
      // Example: Adding a new dependency with peer context awareness
      await appendNodes(
        packageInfo,         // manifest fetcher
        graph,               // target graph
        importerNode,        // starting node
        [{ spec: reactDomSpec, type: 'prod' }], // dependencies
        scurry,              // path resolver
        options,             // spec options
        new Set(),           // seen set
        add,                 // add map
        modifiers,           // modifier system
        modifierRefs,        // active modifier refs
        extractPromises,     // early extraction promises
        actual,              // actual graph for extraction
        seenExtracted,       // extraction tracking set
        remover,             // rollback remover
        transientAdd,        // transient additions
        transientRemove      // transient removals
      )
    output: "Breadth-first processing with peer context management and early extraction"

  - input: |
      // Example: Processing with peer context lifecycle (3-phase architecture)
      // PHASE A - In fetchManifestsForDeps (read-only):
      const peerCompatResult = checkPeerEdgesCompatible(existingNode, fromNode, peerContext, graph)
      if (!peerCompatResult.compatible) {
        forkRequests.push(peerCompatResult.forkEntry)  // Deferred, not applied yet
      }
      if (validExistingNode) {
        reuseTasks.push({ type, spec, fromNode, toNode: existingNode })  // Deferred edge
      }
      return { placementTasks, reuseTasks, forkRequests }

      // PHASE B - Serial mutations (deterministic order):
      if (result.forkRequests.length > 0) {
        entry.peerContext = forkPeerContext(graph, entry.peerContext, result.forkRequests)
      }
      for (const { type, spec, fromNode, toNode } of sortedReuseTasks) {
        graph.addEdge(type, spec, fromNode, toNode)
      }

      // In processPlacementTasks:
      const { peerSetHash, queuedEntries } = startPeerPlacement(peerContext, manifest, fromNode, options)
      const node = graph.placePackage(fromNode, type, spec, manifest, id, joinExtra({ peerSetHash, modifier }))
      const updateContext = endPeerPlacement(...)

      // PHASE C - Post-placement:
      postPlacementPeerCheck(graph, levelResults)
    output: "Complete peer context lifecycle with read-only fetch and serial mutations"

  - input: |
      // Example: Post-placement peer check with context forking
      // From postPlacementPeerCheck in peers.ts
      for (const childDep of sortedChildDeps) {
        const needsFork = childDep.updateContext.putEntries()
        if (needsFork) {
          needsForking.set(childDep, needsFork)
        }
      }

      for (const [childDep, nextEntries] of sortedNeedsForkingEntries) {
        if (prevContext && !checkEntriesToPeerContext(prevContext, nextEntries)) {
          // Reuse sibling's context
          childDep.peerContext = prevContext
        } else {
          // Fork new context
          childDep.peerContext = forkPeerContext(graph, childDep.peerContext, nextEntries)
          prevContext = childDep.peerContext
        }
      }

      for (const childDep of sortedChildDeps) {
        childDep.updateContext.resolvePeerDeps()
      }
    output: "Post-placement peer context forking and resolution with sibling context reuse"

  - input: |
      // Example: Testing workspace peer context isolation
      // Each workspace importer should get its own peer context
      const mainReactEdge = graph.mainImporter.edgesOut.get('react')
      const wsReactEdge = wsImporter.edgesOut.get('react')
      
      t.equal(mainReactEdge?.to?.version, '18.3.1', 'main importer should have react@18')
      t.equal(wsReactEdge?.to?.version, '19.2.0', 'workspace importer should have react@19')
      t.ok(graph.peerContexts.length > 1, 'should have multiple peer contexts for isolation')
    output: "Verified workspace peer context isolation prevents cross-workspace leakage"

  - input: |
      // Example: Candidate fallback when first satisfying node is peer-incompatible
      // Setup: multiple foo candidates with different peer targets
      const peerContext = graph.peerContexts[0]
      peerContext.set('react', { target: react183, ... })  // Context expects react@18.3
      
      // foo@1.0.0 has peer edge to react@18.2 (incompatible)
      // foo@1.0.2 has peer edge to react@18.3 (compatible)
      await appendNodes(packageInfo, graph, mainImporter, [fooDep], ...)
      
      const edge = graph.mainImporter.edgesOut.get('foo')
      t.equal(edge?.to?.id, foo102.id, 'should skip incompatible foo@1.0.0, use foo@1.0.2')
    output: "Candidate fallback selects peer-compatible node over first satisfying node"

metadata:
  priority: high
  version: 2.2
  tags:
    - graph
    - ideal
    - append-nodes
    - breadth-first
    - dependencies
    - modifiers
    - deterministic
    - parallel
    - peer-dependencies
    - peer-context
  related_rules:
    - graph_data_structure
    - graph_ideal
    - graph_modifiers
    - graph_peers
    - graph_lockfiles
    - monorepo_structure
</rule>
