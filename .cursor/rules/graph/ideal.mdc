---
description: Build Ideal Graphs from manifests and starting graphs
globs: src/graph/src/ideal/*
alwaysApply: false
---
# Building Ideal Graphs

Guidance for working with the Ideal Graph builder in `@vltpkg/graph`, which produces the desired end-state graph used for installs.

<rule>
name: graph_ideal
description: How Ideal graphs are constructed, merged with add/remove, and expanded via remote manifests
filters:
  # Ideal builder implementation and helpers
  - type: path
    pattern: "^src/graph/src/ideal/"
  - type: file_name
    pattern: "^(build|build-ideal-from-starting-graph|append-nodes|get-importer-specs|remove-satisfied-specs|refresh-ideal-graph|remove-nodes|types)\\.ts$"
  # High-level orchestration reference
  - type: content
    pattern: "ideal\\.build\(|buildIdealFromStartingGraph\("

actions:
  - type: guide
    message: |
      ## Overview

      The Ideal Graph represents the desired post-install state. It is constructed by:
      1. Selecting a starting graph: prefer Virtual (lockfile) and fall back to Actual (`node_modules`) when needed.
      2. Merging user-provided `add`/`remove` requests with importer manifest deltas.
      3. Expanding dependencies by fetching manifests/artifacts and recursively placing packages.
      4. Reusing existing nodes that satisfy specs to minimize network and duplication.
      5. Optionally extracting tarballs during graph construction for improved performance (early extraction).

      Entry point: `src/graph/src/ideal/build.ts` â†’ `ideal.build(options)`

  - type: architecture_guide
    message: |
      ## Starting Graph Selection (`build.ts`)

      - Attempts to load a Virtual Graph from lockfile first with `skipLoadingNodesOnModifiersChange: true`.
      - On failure, loads the Actual Graph with the same skip flag.
      - Uses shared instances of `packageJson`, `scurry`, and `monorepo` for efficiency.
      - Delegates to `buildIdealFromStartingGraph()` for merging and expansion.

  - type: architecture_guide
    message: |
      ## Merge and Expansion (`build-ideal-from-starting-graph.ts`)

      - Computes importer deltas via `get-importer-specs.ts`:
        - Builds `AddImportersDependenciesMap` and `RemoveImportersDependenciesMap` by comparing importer manifests to the starting graph.
        - Prunes already-satisfied dependencies using `remove-satisfied-specs.ts`.
        - Flags whether dependencies were modified (`modifiedDependencies`).
      - Merges user-provided `add`/`remove` over computed deltas; user input wins.
      - Invokes `refresh-ideal-graph.ts` to fetch and incorporate remote manifests and expand the graph.
      - After expansion, calls `setDefaultLocation()` on nodes to normalize store layout hints.
      - Finally, removes dependencies listed in `remove` via `remove-nodes.ts` and garbage-collects unreachable nodes (`graph.gc()`).

  - type: architecture_guide
    message: |
      ## Node Appending and Reuse (`append-nodes.ts`, `refresh-ideal-graph.ts`)

      - Resolves dependency specs to nodes by first attempting `graph.findResolution()` to reuse existing nodes that satisfy the spec.
      - **Peer Compatibility Check**: Before reusing a node, checks if its peer edges are compatible with the current peer context via `checkPeerEdgesCompatible()`.
      - **Candidate Fallback**: If the first satisfying node is peer-incompatible, tries other candidates deterministically until a compatible one is found.
      - When a satisfying node is not found, fetches manifests/artifacts via `@vltpkg/package-info`, selects appropriate versions (respecting platform/engine constraints), and places new nodes with correct flags.
      - Recursively descends into each newly placed node's dependencies, applying `@vltpkg/spec` parsing and honoring modifiers if present.
      - Ensures added nodes have consistent `registry`, `resolved`, and `integrity` fields as available.

      ðŸ“‹ **See `@graph/ideal-append-nodes.mdc`** for detailed BFS algorithm and peer context lifecycle

  - type: architecture_guide
    message: |
      ## Early Extraction Feature (`append-nodes.ts`)

      - When an `actual` graph is provided to the build process, the Ideal builder can perform early extraction of tarballs.
      - As nodes are placed into the graph, if they don't exist in the actual graph and are destined for the vlt store, extraction begins immediately.
      - Extraction happens in parallel with graph construction, improving overall install performance.
      - The `node.extracted` property tracks whether a node has been extracted to avoid duplicate extractions.
      - This optimization is particularly beneficial when no cached information is available.

  - type: architecture_guide
    message: |
      ## Workspace Peer Context Isolation

      In monorepos with multiple workspace importers, each workspace gets its **own peer context**:

      - **Problem**: Without isolation, peer targets from the root importer could incorrectly influence workspace dependencies
        - Example: Root has `react@^18`, workspace A needs `react@^19` for a peer-dependent package
        - Without isolation, the peer dep might incorrectly resolve to react@18

      - **Solution**: `appendNodes()` creates fresh peer contexts for non-main importers:
        ```typescript
        if (fromNode.importer && fromNode !== graph.mainImporter) {
          const nextPeerContext: PeerContext = new Map()
          nextPeerContext.index = graph.nextPeerContextIndex()
          initialPeerContext = nextPeerContext
        }
        ```

      - **Fork Caching**: `graph.peerContextForkCache` prevents duplicate contexts for identical fork operations
      
      ðŸ“‹ **See `@graph/peers.mdc`** for detailed peer context isolation and fork caching mechanisms

  - type: integration_guide
    message: |
      ## Options and Inputs

      - `projectRoot`, `packageJson`, `scurry`, `monorepo` â€” Required/shared instances for deterministic traversal and manifest access.
      - `packageInfo: PackageInfoClient` â€” Required for remote manifest and artifact retrieval.
      - `add?: AddImportersDependenciesMap` â€” Explicit dependencies to add per importer.
      - `remove?: RemoveImportersDependenciesMap` â€” Explicit dependency names to remove per importer.
      - `actual?: Graph` â€” Optional actual graph to enable early extraction optimization during ideal graph construction.
      - Modifiers integration â€” If `modifiers` are provided, selectors can adjust specs during resolution; Ideal builder will then record modifier info on nodes for downstream awareness.

      ### Behavior and Guarantees
      - Reuses nodes whenever they satisfy requested specs.
      - Expands transitive dependencies recursively using resolved manifests.
      - Produces a graph ready for hoisting and reification, with stable, default locations set where applicable.

  - type: development_workflow
    message: |
      ## Practical Tips

      - Always prefer the lockfile as the starting point for reproducibility.
      - Keep `add`/`remove` mappings minimal; rely on `get-importer-specs.ts` to detect manifest drift.
      - Pass shared `packageJson` and `scurry` instances across phases (Actual/Virtual load â†’ Ideal build â†’ Reify).
      - Use `graph.findResolution()` aggressively in new features to avoid duplicate nodes and redundant network calls.

examples:
  - input: |
      import { ideal } from '@vltpkg/graph'
      const graph = await ideal.build({ projectRoot, packageInfo, packageJson, scurry })
    output: "Ideal graph built from lockfile or actual as starting point"

  - input: |
      // Add and remove across importers
      const add = new Map()
      const remove = new Map()
      const g = await ideal.build({ projectRoot, packageInfo, packageJson, scurry, add, remove })
    output: "Importer deltas merged with user-provided add/remove and expanded"

  - input: |
      // Build ideal with early extraction optimization
      import { ideal, actual } from '@vltpkg/graph'
      const actualGraph = actual.load({ projectRoot, packageJson, scurry })
      const idealGraph = await ideal.build({ 
        projectRoot, 
        packageInfo, 
        packageJson, 
        scurry,
        actual: actualGraph 
      })
    output: "Ideal graph built with early tarball extraction for improved performance"

  - input: |
      // Multi-workspace monorepo with peer context isolation
      // Root: react@^18, workspace-a: react@^19 with peer-dependent packages
      const idealGraph = await ideal.build({ projectRoot, packageInfo, packageJson, scurry, monorepo })
      
      // Each workspace gets isolated peer contexts
      t.ok(idealGraph.peerContexts.length > 1, 'should have multiple peer contexts')
      t.equal(rootReact.version, '18.3.1', 'root has react@18')
      t.equal(wsReact.version, '19.2.0', 'workspace has react@19')
    output: "Ideal graph built with isolated peer contexts per workspace importer"

metadata:
  priority: high
  version: 1.2
  tags:
    - graph
    - ideal
    - build
    - manifests
    - modifiers
    - performance
  related_rules:
    - graph_workspace_architecture
    - graph_data_structure
    - graph_lockfiles
    - graph_load_actual
    - graph_modifiers
    - graph_peers
    - graph_reify
    - monorepo-structure
</rule>

