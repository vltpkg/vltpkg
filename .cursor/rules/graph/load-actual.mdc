---
description: Loading Actual Graphs from node_modules
globs: src/graph/src/actual/*,src/graph/test/actual/*
alwaysApply: false
---
# Loading Actual Graphs (node_modules)

Understanding how `@vltpkg/graph` loads an Actual Graph by traversing a project's `node_modules` and how to use the returned structure.

<rule>
name: graph_load_actual
description: Detailed guidance for loading Actual Graphs from node_modules and using the resulting structure
filters:
  # Core implementation file and directory
  - type: path
    pattern: "^src/graph/src/actual/load\\.ts$"
  - type: path
    pattern: "^src/graph/src/actual/"
  # Hidden lockfile shortcut integration
  - type: content
    pattern: "loadHidden\(\)"
  # Option flags commonly used with actual.load
  - type: content
    pattern: "skipHiddenLockfile|loadManifests|skipLoadingNodesOnModifiersChange"

actions:
  - type: guide
    message: |
      ## What is an Actual Graph?

      An Actual Graph is a representation of what's currently installed on disk in a project, derived by traversing `node_modules`. Its purpose is to reflect the real state of the install so that it can be compared to an Ideal Graph for minimal-change reification.

      Entry point: `src/graph/src/actual/load.ts` → `actual.load(options)`

  - type: architecture_guide
    message: |
      ## High-level Flow

      1. Resolve `mainManifest` (from `options.mainManifest` or `packageJson.read(projectRoot)`).
      2. If `skipHiddenLockfile` is not set, attempt fast-path by loading the Hidden Lockfile via `lockfile.loadHidden()` (file: `node_modules/.vlt-lock.json`). If successful, return that Graph.
      3. Otherwise, construct a new `Graph` seeded with importers (the project and discovered workspaces).
      4. Optionally compare stored modifiers (`node_modules/.vlt/vlt.json`) to `options.modifiers.config`. If `skipLoadingNodesOnModifiersChange` is true and modifiers changed, only importers are loaded (skip dependency traversal).
      5. Perform a breadth-first traversal starting from each importer's `node_modules` folder:
         - Read entries (skipping hidden items), descend into `@scope` folders, and consider only symbolic links as potential dependency links.
         - Resolve real paths, derive alias (symlink name) and normalized package name (handling scopes) for each entry.
         - Place nodes and edges in the graph, reading manifests when required.
      6. Mark extraneous dependencies (present on disk but not listed in importer manifests) when manifests are loaded.
      7. Add dangling edges for missing dependencies (declared but not found on disk).

      The traversal is implemented by helper functions within `load.ts`:
      - `readDir(scurry, currDir, fromNodeName?)` — Scans `node_modules`, recursing into `@scope` directories, returning alias/name/realpath for symlink entries.
      - `parseDir(options, scurry, packageJson, depsFound, graph, fromNode, currDir)` — Places packages, applies modifiers, records extraneous/missing, and queues nested `node_modules` for BFS.

  - type: architecture_guide
    message: |
      ## Identity and Path Handling

      - Path-based specs (`file`, `workspace`) get IDs directly from their path via `getPathBasedId()`.
      - For store-based installs, `findDepID()` walks parent paths until it reaches `.vlt/` store layout (`.vlt/<DepID>/node_modules/<name>`), extracting the `DepID`.
      - `findNodeModules()` finds the nearest `node_modules` directory for a placed node.
      - `findName()` normalizes names, including scoped package folders.

      Placed nodes set `node.location` to a relative path like `./node_modules/...` or `./<realpath>`. Nodes outside the store are treated accordingly by `node.nodeModules(scurry)`.

  - type: integration_guide
    message: |
      ## Options and Behavior

      - `projectRoot: string` — Required. Project directory to scan.
      - `packageJson` (required), `scurry` (required), `monorepo` (optional) — Shared instances; reuse them for performance.
      - `mainManifest?: NormalizedManifest` — Optionally provide the root manifest; otherwise read from disk.
      - `modifiers?: GraphModifier` — Active modifiers affecting spec resolution and node placement.
      - `loadManifests?: boolean` —
        - `true`: Read package manifests for accurate dependency types/specs, and to detect extraneous dependencies.
        - `false`: Do not read manifests; infer default `prod` edges and hydrate specs from `DepID` when possible. No missing/extraneous detection.
      - `skipHiddenLockfile?: boolean` — If `false` (default), attempt Hidden Lockfile fast-path.
      - `skipLoadingNodesOnModifiersChange?: boolean` — Load only importers if modifiers differ from `node_modules/.vlt/vlt.json` saved config.
      - `expectLockfile?` / `frozenLockfile?` — Reserved for commands that enforce lockfile presence/sync (not central to traversal mechanics).

      ### Modifiers Application
      - Before placing packages, the loader consults `modifiers.tryDependencies(fromNode, deps)` to find active selectors.
      - For each dependency, it may replace the spec (eg. apply an override) and record a `queryModifier` that is saved with the `Node` so later phases can reason about modified resolutions.
      - After traversal, `modifiers.rollbackActiveEntries()` clears any partially applied entries.

  - type: development_workflow
    message: |
      ## Using the Returned Actual Graph

      - Nodes may lack manifests when `loadManifests=false`. Avoid relying on dependency type info or declared specs in that mode.
      - Missing dependencies are represented by edges with no `to` node (dangling edges) when manifests are processed; extraneous dependencies are recorded in `graph.extraneousDependencies`.
      - Each node has a `location` and can compute its `nodeModules(scurry)` directory for linking operations.
      - The Actual Graph is commonly diffed against an Ideal Graph using `new Diff(actual, ideal)`, then applied by `reify`.
      - Prefer the Hidden Lockfile fast-path when available to skip filesystem traversal.

      ### Performance Tips
      - Reuse `packageJson`, `scurry`, and `monorepo` instances across phases.
      - Use `skipLoadingNodesOnModifiersChange` strategically when rebuilding after modifier changes.

examples:
  - input: |
      // Load Actual with manifests for accurate extraneous/missing detection
      import { actual } from '@vltpkg/graph'
      const from = actual.load({
        projectRoot,
        packageJson: sharedPackageJson,
        scurry: sharedScurry,
        monorepo: sharedMonorepo,
        loadManifests: true,
      })
    output: "Actual graph loaded from node_modules with manifests"

  - input: |
      // Fast-path from Hidden Lockfile (if present and not skipped)
      import { actual } from '@vltpkg/graph'
      const from = actual.load({
        projectRoot,
        packageJson,
        scurry,
        // skipHiddenLockfile: false (default)
      })
    output: "Actual graph loaded from node_modules/.vlt-lock.json when available"

  - input: |
      // No-manifest mode (faster, limited details, defaults to prod edges)
      const from = actual.load({ projectRoot, packageJson, scurry, loadManifests: false })
    output: "Actual graph loaded without reading manifests; no extraneous/missing computed"

metadata:
  priority: high
  version: 1.0
  tags:
    - graph
    - actual
    - node_modules
    - filesystem
    - performance
    - modifiers
  related_rules:
    - graph_workspace_architecture
    - graph_data_structure
    - graph_lockfiles
    - graph_modifiers
</rule>

