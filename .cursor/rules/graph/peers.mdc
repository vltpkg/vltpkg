---
description: Peer dependency context isolation and resolution in vlt graphs
globs: src/graph/src/ideal/peers.ts,src/graph/test/ideal/peers.ts,src/graph/src/graph.ts,src/dep-id/src/browser.ts
alwaysApply: false
---
# Peer Dependencies in Graph

Comprehensive guide to peer dependency handling in `@vltpkg/graph`, covering context isolation, package duplication, and the `peerSetHash` mechanism.

<rule>
name: graph_peers
description: How vlt isolates peer dependency contexts and duplicates packages when peer requirements differ
filters:
  # Peer dependency implementation files
  - type: path
    pattern: "^src/graph/src/ideal/peers\\.ts$"
  - type: path
    pattern: "^src/graph/test/ideal/peers\\.ts$"
  # DepID utilities for extra parameter handling
  - type: path
    pattern: "^src/dep-id/src/(browser|index)\\.ts$"
  # Graph core that handles peerSetHash
  - type: path
    pattern: "^src/graph/src/graph\\.ts$"
  # Node class with peerSetHash property
  - type: path
    pattern: "^src/graph/src/node\\.ts$"
  # Mentions of peer dependencies in content
  - type: content
    pattern: "peerSetHash|peerDependencies|splitExtra|joinExtra|peer context"

actions:
  - type: guide
    message: |
      ## Overview

      vlt handles peer dependencies by **isolating peer contexts**, allowing multiple versions of the same package to coexist when different dependency trees require incompatible peer versions.

      Key behaviors:
      - **Attempts reuse first**: vlt tries to resolve to a single unique version that satisfies all peer contexts
      - **Forks contexts when needed**: when a single version cannot satisfy all requirements, vlt subdivides the dependency graph into peer context groups
      - **Duplicates packages**: packages requiring different peer versions are duplicated in the vlt store
      - **Tracks contexts**: uses `peerSetHash` internally to identify and duplicate nodes affected by peer context modifications

  - type: architecture_guide
    message: |
      ## Peer Context Isolation (`src/graph/src/ideal/peers.ts`)

      Core algorithm:
      1. **Analyze current peer context**: Check if existing resolved nodes can satisfy new peer dependencies
      2. **Attempt reuse**: Try to use a single version across all occurrences of the peer dependency
      3. **Fork when necessary**: Create new peer contexts when version conflicts arise
      4. **Duplicate nodes**: Clone package nodes that need different peer versions
      5. **Track with peerSetHash**: Append unique identifiers to DepIDs to distinguish peer contexts

      Implementation details:
      - Peer contexts are deterministically identified using `peerSetHash` strings (format: `ṗ:N` where N is a numeric identifier)
      - The `peerSetHash` is appended to the node's DepID as part of the `extra` parameter
      - Multiple versions of the same package can exist in the graph, differentiated by their `peerSetHash`

  - type: architecture_guide
    message: |
      ## DepID Extra Parameter (`src/dep-id/src/browser.ts`)

      The `extra` parameter in DepIDs now serves dual purposes:
      1. **Modifier**: Query-based graph modifications (e.g., `:root > #package`)
      2. **peerSetHash**: Peer context identifier (e.g., `ṗ:1`, `ṗ:2`)

      ### Utilities

      **`joinExtra({ modifier?, peerSetHash? })`**
      - Combines modifier and peerSetHash into a single string
      - Returns `undefined` if both are empty
      - Concatenates without separator when both present: `${modifier}${peerSetHash}`
      - Examples:
        - `joinExtra({ modifier: ':root > #pkg' })` → `':root > #pkg'`
        - `joinExtra({ peerSetHash: 'ṗ:1' })` → `'ṗ:1'`
        - `joinExtra({ modifier: ':root > #pkg', peerSetHash: 'ṗ:1' })` → `':root > #pkgṗ:1'`

      **`splitExtra(extra: string)`**
      - Parses an extra string into its components
      - Detects peerSetHash by looking for `ṗ:` delimiter
      - Returns `{ modifier?, peerSetHash? }`
      - Examples:
        - `splitExtra('ṗ:1')` → `{ peerSetHash: 'ṗ:1' }`
        - `splitExtra(':root > #pkg')` → `{ modifier: ':root > #pkg' }`
        - `splitExtra(':root > #pkgṗ:2')` → `{ modifier: ':root > #pkg', peerSetHash: 'ṗ:2' }`

  - type: architecture_guide
    message: |
      ## Node peerSetHash Property (`src/graph/src/node.ts`)

      Nodes now have an optional `peerSetHash?: string` property:
      - Set during ideal graph construction when peer context forking occurs
      - Included in node serialization (lockfile, JSON output)
      - Preserved during graph operations (reset, gc, etc.)
      - Used to identify nodes that are duplicates for peer context isolation

      The property is:
      - Parsed from DepID's extra parameter during lockfile load
      - Set by peer resolution logic during ideal graph building
      - Combined with modifier when constructing resolution cache keys

  - type: architecture_guide
    message: |
      ## Graph Integration (`src/graph/src/graph.ts`)

      ### Resolution Cache
      - Cache keys now include the full `extra` string (both modifier and peerSetHash)
      - `getResolutionCacheKey(spec, location, extra)` incorporates both components
      - Ensures nodes with different peer contexts don't incorrectly share resolution cache entries

      ### Node Placement
      - `placePackage()` accepts `extra` parameter containing combined modifier + peerSetHash
      - Automatically splits `extra` and assigns to `node.modifier` and `node.peerSetHash`
      - `findResolution()` accepts `extra` for cache key construction

      ### nodesByName Ordering
      - The `nodesByName` set is now sorted deterministically by DepID
      - Ensures consistent graph resolution when reusing nodes across peer contexts
      - Sorting happens in `addNode()` after adding new nodes to the set

  - type: integration_guide
    message: |
      ## Query Selectors for Peer Dependencies

      Users can inspect peer dependencies using DSS selectors:

      - `:peer` — Returns all peer dependencies in the project
      - `:peer:optional` — Returns optional peer dependencies (potentially missing)
      - `:has(:peer)` — Returns packages that have direct peer dependencies
      - `:peerOptional` — Returns peer dependencies marked as both peer and optional

      These selectors are documented in the user-facing docs at `www/docs/src/content/docs/cli/peer-dependencies.mdx`

  - type: data_format_guide
    message: |
      ## Lockfile Representation

      Peer context information is preserved in lockfiles:

      **Nodes**: DepID includes peerSetHash in the extra parameter
      ```
      "··package@1.0.0·ṗ:1": [...]
      "··package@1.0.0·ṗ:2": [...]
      ```

      **Edges**: References include the full DepID with peerSetHash
      ```
      "file·. package": "prod ^1.0.0 ··package@1.0.0·ṗ:1"
      ```

      **Loading**: `loadNodes()` in `src/graph/src/lockfile/load-nodes.ts` uses `splitExtra()` to parse both modifier and peerSetHash from the DepID

  - type: development_workflow
    message: |
      ## Testing Peer Dependencies

      Test files: `src/graph/test/ideal/peers.ts`

      Key test scenarios:
      - Multiple major versions of the same peer (React 18 vs 19)
      - Peer dependency cycles (e.g., `@isaacs/peer-dep-cycle-a/b/c`)
      - Optional peer dependencies
      - Flexible peer ranges that can be satisfied by multiple versions
      - Mixed contexts where some dependencies share peers and others don't

      Testing patterns:
      - Build ideal graphs with packages declaring peer dependencies
      - Verify correct number of duplicate nodes created
      - Check that peerSetHash values are assigned and unique
      - Validate lockfile serialization includes peerSetHash
      - Confirm query selectors return expected peer dependency sets
      - Test mermaid diagram generation showing peer context isolation

  - type: development_workflow
    message: |
      ## Practical Tips

      When working with peer dependencies:
      - **Always use joinExtra()**: When constructing extra parameters, use `joinExtra({ modifier, peerSetHash })` rather than string concatenation
      - **Always use splitExtra()**: When parsing extra parameters, use `splitExtra(extra)` to correctly handle both components
      - **Preserve peerSetHash**: When copying or transforming nodes, ensure peerSetHash is maintained
      - **Cache key awareness**: Resolution cache keys must include the full extra string to avoid incorrect cache hits
      - **Test with real packages**: Use actual npm packages with peer dependencies (like React ecosystem) for integration tests
      - **Check lockfile round-trips**: Verify that peerSetHash survives serialization and deserialization

examples:
  - input: |
      // Correctly combining modifier and peerSetHash
      const extra = joinExtra({ 
        modifier: ':root > #react-dom', 
        peerSetHash: 'ṗ:1' 
      })
      const node = graph.placePackage(from, 'prod', spec, manifest, id, extra)
    output: "Node placed with both modifier and peer context tracking"

  - input: |
      // Parsing extra from DepID during lockfile load
      const { modifier, peerSetHash } = splitExtra(extra)
      if (modifier) node.modifier = modifier
      if (peerSetHash) node.peerSetHash = peerSetHash
    output: "Extra parameter correctly split into components"

  - input: |
      // Finding resolution with peer context
      const extra = joinExtra({ peerSetHash: 'ṗ:2' })
      const resolved = graph.findResolution(spec, fromNode, extra)
    output: "Resolution respects peer context isolation"

metadata:
  priority: high
  version: 1.0
  tags:
    - graph
    - peer-dependencies
    - context-isolation
    - node-duplication
    - dep-id
    - lockfile
  related_rules:
    - graph_data_structure
    - graph_ideal
    - graph_lockfiles
    - monorepo-structure
</rule>
