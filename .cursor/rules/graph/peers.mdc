---
description: Peer dependency context isolation and resolution in vlt graphs
globs: src/graph/src/ideal/peers.ts,src/graph/test/ideal/peers.ts,src/graph/src/graph.ts,src/dep-id/src/browser.ts
alwaysApply: false
---
# Peer Dependencies in Graph

Comprehensive guide to peer dependency handling in `@vltpkg/graph`, covering context isolation, package duplication, and the `peerSetHash` mechanism.

<rule>
name: graph_peers
description: How vlt isolates peer dependency contexts and duplicates packages when peer requirements differ
filters:
  # Peer dependency implementation files
  - type: path
    pattern: "^src/graph/src/ideal/peers\\.ts$"
  - type: path
    pattern: "^src/graph/test/ideal/peers\\.ts$"
  # DepID utilities for extra parameter handling
  - type: path
    pattern: "^src/dep-id/src/(browser|index)\\.ts$"
  # Graph core that handles peerSetHash
  - type: path
    pattern: "^src/graph/src/graph\\.ts$"
  # Node class with peerSetHash property
  - type: path
    pattern: "^src/graph/src/node\\.ts$"
  # Mentions of peer dependencies in content
  - type: content
    pattern: "peerSetHash|peerDependencies|splitExtra|joinExtra|peer context"

actions:
  - type: guide
    message: |
      ## Overview

      vlt handles peer dependencies by **isolating peer contexts**, allowing multiple versions of the same package to coexist when different dependency trees require incompatible peer versions.

      Key behaviors:
      - **Attempts reuse first**: vlt tries to resolve to a single unique version that satisfies all peer contexts
      - **Forks contexts when needed**: when a single version cannot satisfy all requirements, vlt subdivides the dependency graph into peer context groups
      - **Duplicates packages**: packages requiring different peer versions are duplicated in the vlt store
      - **Tracks contexts**: uses `peerSetHash` internally to identify and duplicate nodes affected by peer context modifications

  - type: architecture_guide
    message: |
      ## Peer Context Isolation (`src/graph/src/ideal/peers.ts`)

      Core algorithm:
      1. **Analyze current peer context**: Check if existing resolved nodes can satisfy new peer dependencies
      2. **Attempt reuse**: Try to use a single version across all occurrences of the peer dependency
      3. **Fork when necessary**: Create new peer contexts when version conflicts arise
      4. **Duplicate nodes**: Clone package nodes that need different peer versions
      5. **Track with peerSetHash**: Append unique identifiers to DepIDs to distinguish peer contexts

      Implementation details:
      - Peer contexts are deterministically identified using `peerSetHash` strings (format: `peer.N` where N is a numeric identifier)
      - The `peerSetHash` is appended to the node's DepID as part of the `extra` parameter
      - Multiple versions of the same package can exist in the graph, differentiated by their `peerSetHash`

      ### Helper Functions
      The module uses several internal helper functions to reduce duplication:
      - **`nodeSatisfiesSpec(node, spec, fromNode, graph)`**: Wraps common `satisfies()` call pattern
      - **`parseSpec(name, bareSpec, fromNode, graph)`**: Wraps `Spec.parse` with registry options
      - **`getForkKey(peerContext, entries)`**: Generates cache key for fork operations (format: `{baseIndex}::{signatures}`)
      - **`shouldIgnoreContextMismatch()`**: Prevents cross-importer peer context leakage
      - **`buildIncompatibleResult()`**: Creates fork entry when target satisfies peer spec
      - **`findFromPeerClosure()`**: BFS search through peer edges (depth limit: 3) for cycle resolution

  - type: architecture_guide
    message: |
      ## DepID Extra Parameter (`src/dep-id/src/browser.ts`)

      The `extra` parameter in DepIDs now serves dual purposes:
      1. **Modifier**: Query-based graph modifications (e.g., `:root > #package`)
      2. **peerSetHash**: Peer context identifier (e.g., `peer.1`, `peer.2`)

      ### Utilities

      **`joinExtra({ modifier?, peerSetHash? })`**
      - Combines modifier and peerSetHash into a single string
      - Returns `undefined` if both are empty
      - Concatenates without separator when both present: `${modifier}${peerSetHash}`
      - Examples:
        - `joinExtra({ modifier: ':root > #pkg' })` → `':root > #pkg'`
        - `joinExtra({ peerSetHash: 'peer.1' })` → `'peer.1'`
        - `joinExtra({ modifier: ':root > #pkg', peerSetHash: 'peer.1' })` → `':root > #pkgpeer.1'`

      **`splitExtra(extra: string)`**
      - Parses an extra string into its components
      - Detects peerSetHash by looking for `peer.` delimiter
      - Returns `{ modifier?, peerSetHash? }`
      - Examples:
        - `splitExtra('peer.1')` → `{ peerSetHash: 'peer.1' }`
        - `splitExtra(':root > #pkg')` → `{ modifier: ':root > #pkg' }`
        - `splitExtra(':root > #pkgpeer.2')` → `{ modifier: ':root > #pkg', peerSetHash: 'peer.2' }`

  - type: architecture_guide
    message: |
      ## Node peerSetHash Property (`src/graph/src/node.ts`)

      Nodes now have an optional `peerSetHash?: string` property:
      - Set during ideal graph construction when peer context forking occurs
      - Included in node serialization (lockfile, JSON output)
      - Preserved during graph operations (reset, gc, etc.)
      - Used to identify nodes that are duplicates for peer context isolation

      The property is:
      - Parsed from DepID's extra parameter during lockfile load
      - Set by peer resolution logic during ideal graph building
      - Combined with modifier when constructing resolution cache keys

  - type: architecture_guide
    message: |
      ## Graph Integration (`src/graph/src/graph.ts`)

      ### Resolution Cache
      - Cache keys now include the full `extra` string (both modifier and peerSetHash)
      - `getResolutionCacheKey(spec, location, extra)` incorporates both components
      - Ensures nodes with different peer contexts don't incorrectly share resolution cache entries

      ### Node Placement
      - `placePackage()` accepts `extra` parameter containing combined modifier + peerSetHash
      - Automatically splits `extra` and assigns to `node.modifier` and `node.peerSetHash`
      - `findResolution()` accepts `extra` for cache key construction

      ### nodesByName Ordering
      - The `nodesByName` set is now sorted deterministically by DepID
      - Ensures consistent graph resolution when reusing nodes across peer contexts
      - Sorting happens in `addNode()` after adding new nodes to the set

      ### Peer Context Fork Cache
      - `graph.peerContextForkCache: Map<string, PeerContext>` caches forked contexts
      - Prevents creating duplicate contexts for identical fork operations
      - Key format: `{baseIndex}::{sortedEntrySignatures}` (constructed by `getForkKey()`)
      - Significantly reduces memory usage in multi-workspace scenarios

  - type: architecture_guide
    message: |
      ## Key Algorithms

      ### `checkPeerEdgesCompatible()` - 3-Phase Compatibility Check
      Determines if a node can be reused given the current peer context:

      1. **CHECK 1 - Context Mismatch**: If peer context has a different target for this peer name
         - Returns incompatible with fork entry pointing to context's preferred target
         - Exception: Ignores mismatch if parent's direct dep satisfies a different spec

      2. **CHECK 2 - Placed Siblings**: Check already-placed sibling nodes in the graph
         - Searches `graph.nodesByName` for nodes that satisfy both parent's and peer's specs
         - Returns incompatible if a better candidate exists

      3. **CHECK 3 - Unplaced Siblings**: Check queued entries in peer context
         - Ensures consistency with not-yet-placed siblings

      ### `resolvePeerDeps()` - 4-Priority Resolution
      Resolves peer dependencies after node placement:

      1. **PRIORITY 1 - Direct Sibling**: Sibling of the same parent (same-level dep)
      2. **PRIORITY 2 - Peer Closure**: BFS through peer edges of sibling targets (depth limit: 3)
         - Handles cycles like A→B(peer)→C(peer)→A(peer)
      3. **PRIORITY 3 - Peer Context**: Look up target in peer context entries
      4. **PRIORITY 4 - Defer**: Add to next level deps for later resolution

      ### `postPlacementPeerCheck()` - 3-Phase Post-Level Processing
      Called after all nodes at a level are placed:

      1. **PHASE 1 - Collect**: Call `putEntries()` on all children, collect which need forking
      2. **PHASE 2 - Fork/Reuse**: Create new contexts or reuse sibling contexts when compatible
      3. **PHASE 3 - Resolve**: Call `resolvePeerDeps()` on all children

  - type: integration_guide
    message: |
      ## Query Selectors for Peer Dependencies

      Users can inspect peer dependencies using DSS selectors:

      - `:peer` — Returns all peer dependencies in the project
      - `:peer:optional` — Returns optional peer dependencies (potentially missing)
      - `:has(:peer)` — Returns packages that have direct peer dependencies
      - `:peerOptional` — Returns peer dependencies marked as both peer and optional

      These selectors are documented in the user-facing docs at `www/docs/src/content/docs/cli/peer-dependencies.mdx`

  - type: data_format_guide
    message: |
      ## Lockfile Representation

      Peer context information is preserved in lockfiles:

      **Nodes**: DepID includes peerSetHash in the extra parameter
      ```
      "~~package@1.0.0~peer.1": [...]
      "~~package@1.0.0~peer.2": [...]
      ```

      **Edges**: References include the full DepID with peerSetHash
      ```
      "file~. package": "prod ^1.0.0 ~~package@1.0.0~peer.1"
      ```

      **Loading**: `loadNodes()` in `src/graph/src/lockfile/load-nodes.ts` uses `splitExtra()` to parse both modifier and peerSetHash from the DepID

  - type: architecture_guide
    message: |
      ## Workspace Peer Context Isolation

      Each workspace importer gets its **own peer context** to prevent cross-workspace peer leakage.

      ### The Problem
      Without isolation, peer targets from the root importer could incorrectly influence workspace dependencies:
      - Root: `react@^18` → resolves to `react@18.3.1`
      - Workspace A: `react@^19` with peer-dependent package
      - Without isolation: peer dep might incorrectly resolve to 18.3.1

      ### The Solution
      In `appendNodes()`, non-main importers get fresh peer contexts:
      ```typescript
      if (fromNode.importer && fromNode !== graph.mainImporter) {
        const nextPeerContext: PeerContext = new Map()
        nextPeerContext.index = graph.nextPeerContextIndex()
        graph.peerContexts[nextPeerContext.index] = nextPeerContext
        initialPeerContext = nextPeerContext
      }
      ```

      ### Test Coverage
      - `test/ideal/peers.ts`: "multi-workspace peer context isolation with 4 workspaces"
      - `test/ideal/append-nodes.ts`: "creates fresh peer context for non-main workspace importers"

  - type: development_workflow
    message: |
      ## Testing Peer Dependencies

      Test files: `src/graph/test/ideal/peers.ts`

      Key test scenarios:
      - Multiple major versions of the same peer (React 18 vs 19)
      - Peer dependency cycles (e.g., `@isaacs/peer-dep-cycle-a/b/c`)
      - Optional peer dependencies
      - Flexible peer ranges that can be satisfied by multiple versions
      - Mixed contexts where some dependencies share peers and others don't
      - **Multi-workspace peer context isolation** (4+ workspaces with different peer requirements)
      - **Outlier peer contexts** (workspace sibling with different peer targets)

      Testing patterns:
      - Build ideal graphs with packages declaring peer dependencies
      - Verify correct number of duplicate nodes created
      - Check that peerSetHash values are assigned and unique
      - Validate lockfile serialization includes peerSetHash
      - Confirm query selectors return expected peer dependency sets
      - Test mermaid diagram generation showing peer context isolation
      - **Verify `graph.peerContexts.length > 1` for multi-workspace isolation**

  - type: development_workflow
    message: |
      ## Practical Tips

      When working with peer dependencies:
      - **Always use joinExtra()**: When constructing extra parameters, use `joinExtra({ modifier, peerSetHash })` rather than string concatenation
      - **Always use splitExtra()**: When parsing extra parameters, use `splitExtra(extra)` to correctly handle both components
      - **Preserve peerSetHash**: When copying or transforming nodes, ensure peerSetHash is maintained
      - **Cache key awareness**: Resolution cache keys must include the full extra string to avoid incorrect cache hits
      - **Test with real packages**: Use actual npm packages with peer dependencies (like React ecosystem) for integration tests
      - **Check lockfile round-trips**: Verify that peerSetHash survives serialization and deserialization

examples:
  - input: |
      // Correctly combining modifier and peerSetHash
      const extra = joinExtra({ 
        modifier: ':root > #react-dom', 
        peerSetHash: 'peer.1' 
      })
      const node = graph.placePackage(from, 'prod', spec, manifest, id, extra)
    output: "Node placed with both modifier and peer context tracking"

  - input: |
      // Parsing extra from DepID during lockfile load
      const { modifier, peerSetHash } = splitExtra(extra)
      if (modifier) node.modifier = modifier
      if (peerSetHash) node.peerSetHash = peerSetHash
    output: "Extra parameter correctly split into components"

  - input: |
      // Finding resolution with peer context
      const extra = joinExtra({ peerSetHash: 'peer.2' })
      const resolved = graph.findResolution(spec, fromNode, extra)
    output: "Resolution respects peer context isolation"

  - input: |
      // Using helper functions to check peer compatibility
      import { nodeSatisfiesSpec, parseSpec, checkPeerEdgesCompatible } from './peers.ts'
      
      // Check if node satisfies spec with proper context
      const satisfies = nodeSatisfiesSpec(candidateNode, peerSpec, fromNode, graph)
      
      // Parse spec with registry options from main importer
      const spec = parseSpec('react', '^18.0.0', fromNode, graph)
      
      // Full peer compatibility check (3 phases)
      const result = checkPeerEdgesCompatible(existingNode, fromNode, peerContext, graph)
      if (!result.compatible && result.forkEntry) {
        // Need to fork context with this entry
        const forked = forkPeerContext(graph, peerContext, [result.forkEntry])
      }
    output: "Peer compatibility checked using helper functions and context forked if needed"

  - input: |
      // Peer context fork caching in action
      // In forkPeerContext():
      const cacheKey = getForkKey(base, entries)  // e.g., "0::react:^18.0.0:npm:react@18.3.1"
      const cached = graph.peerContextForkCache.get(cacheKey)
      if (cached) return cached  // Reuse existing forked context
      
      // Create new context and cache it
      const forked = new Map(base) as PeerContext
      forked.index = graph.nextPeerContextIndex()
      graph.peerContextForkCache.set(cacheKey, forked)
    output: "Fork caching prevents duplicate peer contexts in multi-workspace scenarios"

metadata:
  priority: high
  version: 1.2
  tags:
    - graph
    - peer-dependencies
    - context-isolation
    - node-duplication
    - dep-id
    - lockfile
  related_rules:
    - graph_data_structure
    - graph_ideal
    - graph_ideal_append_nodes
    - graph_lockfiles
    - monorepo-structure
</rule>
