import { error } from '@vltpkg/error-cause'
import {
  asPostcssNodeWithChildren,
  asStringNode,
  asTagNode,
  isStringNode,
  isTagNode,
} from '@vltpkg/dss-parser'
import {
  assertSecurityArchive,
  removeDanglingEdges,
  removeNode,
  removeQuotes,
} from './helpers.ts'
import type { ParserState } from '../types.ts'
import type { PostcssNode } from '@vltpkg/dss-parser'

export type MalwareKinds =
  | '0'
  | '1'
  | '2'
  | '3'
  | 'critical'
  | 'high'
  | 'medium'
  | 'low'
  | undefined

export type MalwareAlertTypes =
  | 'malware'
  | 'gptMalware'
  | 'gptSecurity'
  | 'gptAnomaly'
  | undefined

export type MalwareComparator = '>' | '<' | '>=' | '<=' | undefined

const kindsMap = new Map<MalwareKinds, MalwareAlertTypes>([
  ['critical', 'malware'],
  ['high', 'gptMalware'],
  ['medium', 'gptSecurity'],
  ['low', 'gptAnomaly'],
  ['0', 'malware'],
  ['1', 'gptMalware'],
  ['2', 'gptSecurity'],
  ['3', 'gptAnomaly'],
])

// Map numerical values to their respective kinds for comparison operations
const kindLevelMap = new Map<MalwareKinds, number>([
  ['critical', 0],
  ['high', 1],
  ['medium', 2],
  ['low', 3],
  ['0', 0],
  ['1', 1],
  ['2', 2],
  ['3', 3],
])

const kinds = new Set(kindsMap.keys())

export const isMalwareKind = (
  value?: string,
): value is MalwareKinds => kinds.has(value as MalwareKinds)

export const asMalwareKind = (value?: string): MalwareKinds => {
  if (!isMalwareKind(value)) {
    throw error('Expected a valid malware kind', {
      found: value,
      validOptions: Array.from(kinds),
    })
  }
  return value
}

export const parseInternals = (
  nodes: PostcssNode[],
): { kind: MalwareKinds; comparator: MalwareComparator } => {
  // Handle case where no parameters are provided (parameterless :malware)
  if (!nodes[0]) {
    return { kind: undefined, comparator: undefined }
  }

  const selectorNode = asPostcssNodeWithChildren(nodes[0])
  if (!selectorNode.nodes[0]) {
    return { kind: undefined, comparator: undefined }
  }

  let kindValue = ''
  let comparator: MalwareComparator = undefined
  let kind: MalwareKinds

  // Parse the parameter (kind with optional comparator)
  if (isStringNode(selectorNode.nodes[0])) {
    kindValue = removeQuotes(
      asStringNode(selectorNode.nodes[0]).value,
    )
  } else if (isTagNode(selectorNode.nodes[0])) {
    kindValue = asTagNode(selectorNode.nodes[0]).value
  }

  // Extract comparator if present
  if (kindValue.startsWith('>=')) {
    comparator = '>='
    kindValue = kindValue.substring(2)
  } else if (kindValue.startsWith('<=')) {
    comparator = '<='
    kindValue = kindValue.substring(2)
  } else if (kindValue.startsWith('>')) {
    comparator = '>'
    kindValue = kindValue.substring(1)
  } else if (kindValue.startsWith('<')) {
    comparator = '<'
    kindValue = kindValue.substring(1)
  }

  // Validate the kind without comparator
  if (!comparator) {
    kind = asMalwareKind(kindValue)
  } else {
    // For comparisons, just make sure it's a valid numeric value or a valid kind
    if (isMalwareKind(kindValue)) {
      kind = kindValue
    } else {
      throw error(
        'Expected a valid malware kind or number between 0-3',
        {
          found: kindValue,
        },
      )
    }
  }

  return { kind, comparator }
}

/**
 * :malware Pseudo-Selector, matches nodes with malware alerts.
 *
 * Usage:
 * - :malware - matches malware with severity >= medium (critical, high, medium but not low)
 * - :malware(critical) - matches specific malware kind
 * - :malware(>1) - matches malware with severity greater than 1
 * - :malware(">=medium") - matches malware with severity >= medium
 */
export const malware = async (state: ParserState) => {
  assertSecurityArchive(state, 'malware')

  let internals
  try {
    internals = parseInternals(
      asPostcssNodeWithChildren(state.current).nodes,
    )
  } catch (err) {
    throw error('Failed to parse :malware selector', { cause: err })
  }

  const { kind, comparator } = internals
  const alertName = comparator ? undefined : kindsMap.get(kind)

  for (const node of state.partial.nodes) {
    const report = state.securityArchive.get(node.id)
    // Always exclude nodes that don't have security data or alerts
    if (!report?.alerts || report.alerts.length === 0) {
      removeNode(state, node)
    }
  }

  for (const node of state.partial.nodes) {
    const report = state.securityArchive.get(node.id)
    let exclude = true

    if (report) {
      if (kind === undefined && comparator === undefined) {
        // Parameterless :malware - match malware alerts with severity >= medium (exclude low/gptAnomaly)
        exclude = !report.alerts.some(
          alert =>
            alert.type === 'malware' ||
            alert.type === 'gptMalware' ||
            alert.type === 'gptSecurity',
        )
      } else if (comparator) {
        // retrieve the value to compare against
        const kindLevel = kindLevelMap.get(kind)
        // the kindLevel value has already been validated at this point
        // and thus can never return an undefined/falsy value but ts doesn't
        // know about that, so we have the extra check here
        /* c8 ignore next - impossible */
        if (kindLevel == null) break

        // Check each alert to find any that match our comparison criteria
        for (const alert of report.alerts) {
          // Get the numerical value of the alert type
          const alertType = alert.type

          // retrieve a key to the current alert level to be compared against
          const currentAlertLevelKey = [...kindsMap.entries()].find(
            ([_, alertValue]) => alertValue === alertType,
          )?.[0]

          // perform the comparison based on the user-provided kindLevel
          if (currentAlertLevelKey) {
            const currentAlertLevel = kindLevelMap.get(
              currentAlertLevelKey,
            )
            /* c8 ignore next - impossible but ts doesn't know */
            if (currentAlertLevel == null) continue

            switch (comparator) {
              case '>':
                if (currentAlertLevel > kindLevel) {
                  exclude = false
                }
                break
              case '<':
                if (currentAlertLevel < kindLevel) {
                  exclude = false
                }
                break
              case '>=':
                if (currentAlertLevel >= kindLevel) {
                  exclude = false
                }
                break
              case '<=':
                if (currentAlertLevel <= kindLevel) {
                  exclude = false
                }
                break
            }

            // If we've found a match, no need to check other alerts
            if (!exclude) break
          }
        }
      } else {
        // Original exact match behavior
        exclude = !report.alerts.some(
          alert => alert.type === alertName,
        )
      }
    }

    if (exclude) {
      removeNode(state, node)
    }
  }

  removeDanglingEdges(state)

  return state
}
