import t from 'tap'
import { joinDepIDTuple } from '@vltpkg/dep-id'
import { asSecurityArchiveLike } from '@vltpkg/security-archive'
import { getSimpleGraph } from '../fixtures/graph.ts'
import type { ParserState } from '../../src/types.ts'
import {
  malware,
  isMalwareKind,
  asMalwareKind,
  parseInternals,
} from '../../src/pseudo/malware.ts'
import { parse } from '../../src/parser.ts'
import { asPostcssNodeWithChildren } from '../../src/types.ts'

t.test('selects packages with a specific malware kind', async t => {
  const getState = (query: string, graph = getSimpleGraph()) => {
    const ast = parse(query)
    const current = ast.first.first
    const state: ParserState = {
      current,
      initial: {
        edges: new Set(graph.edges.values()),
        nodes: new Set(graph.nodes.values()),
      },
      partial: {
        edges: new Set(graph.edges.values()),
        nodes: new Set(graph.nodes.values()),
      },
      collect: {
        edges: new Set(),
        nodes: new Set(),
      },
      cancellable: async () => {},
      walk: async i => i,
      securityArchive: asSecurityArchiveLike(
        new Map([
          [
            joinDepIDTuple(['registry', '', 'a@1.0.0']),
            {
              id: joinDepIDTuple(['registry', '', 'a@1.0.0']),
              alerts: [{ type: 'malware' }],
            },
          ],
          [
            joinDepIDTuple(['registry', '', 'b@1.0.0']),
            {
              id: joinDepIDTuple(['registry', '', 'b@1.0.0']),
              alerts: [{ type: 'gptMalware' }],
            },
          ],
          [
            joinDepIDTuple(['registry', '', 'c@1.0.0']),
            {
              id: joinDepIDTuple(['registry', '', 'c@1.0.0']),
              alerts: [{ type: 'gptSecurity' }],
            },
          ],
          [
            joinDepIDTuple(['registry', '', 'd@1.0.0']),
            {
              id: joinDepIDTuple(['registry', '', 'd@1.0.0']),
              alerts: [{ type: 'gptAnomaly' }],
            },
          ],
          [
            joinDepIDTuple(['registry', '', 'e@1.0.0']),
            {
              id: joinDepIDTuple(['registry', '', 'e@1.0.0']),
              alerts: [{ type: 'malware' }],
            },
          ],
          [
            joinDepIDTuple(['registry', '', 'f@1.0.0']),
            {
              id: joinDepIDTuple(['registry', '', 'f@1.0.0']),
              alerts: [{ type: 'gptMalware' }],
            },
          ],
        ]),
      ),
      specOptions: {},
      retries: 0,
      signal: new AbortController().signal,
    }
    return state
  }

  await t.test(
    'filter out any node that does not have the malware alert',
    async t => {
      const res = await malware(getState(':malware("critical")'))
      t.strictSame(
        [...res.partial.nodes].map(n => n.name),
        ['a', 'e'],
        'should select only packages with the specified malware alert',
      )
      t.matchSnapshot({
        nodes: [...res.partial.nodes].map(n => n.name),
        edges: [...res.partial.edges].map(e => e.name),
      })
    },
  )

  await t.test('filter using numbered param', async t => {
    const res = await malware(getState(':malware(0)'))
    t.strictSame(
      [...res.partial.nodes].map(n => n.name),
      ['a', 'e'],
      'should select only packages with the specified malware alert',
    )
    t.matchSnapshot({
      nodes: [...res.partial.nodes].map(n => n.name),
      edges: [...res.partial.edges].map(e => e.name),
    })
  })

  await t.test('filter out using unquoted param', async t => {
    const res = await malware(getState(':malware(high)'))
    t.strictSame(
      [...res.partial.nodes].map(n => n.name),
      ['b', 'f'],
      'should select only packages with the specified malware alert',
    )
    t.matchSnapshot({
      nodes: [...res.partial.nodes].map(n => n.name),
      edges: [...res.partial.edges].map(e => e.name),
    })
  })

  await t.test(
    'greater than comparator with number (unquoted)',
    async t => {
      const res = await malware(getState(':malware(>1)'))
      t.strictSame(
        [...res.partial.nodes].map(n => n.name).sort(),
        ['c', 'd'],
        'should select packages with malware kind greater than 1',
      )
      t.matchSnapshot({
        nodes: [...res.partial.nodes].map(n => n.name).sort(),
        edges: [...res.partial.edges].map(e => e.name).sort(),
      })
    },
  )

  await t.test(
    'greater than comparator with string kind (quoted)',
    async t => {
      const res = await malware(getState(':malware(">high")'))
      t.strictSame(
        [...res.partial.nodes].map(n => n.name).sort(),
        ['c', 'd'],
        'should select packages with malware kind greater than high',
      )
      t.matchSnapshot({
        nodes: [...res.partial.nodes].map(n => n.name).sort(),
        edges: [...res.partial.edges].map(e => e.name).sort(),
      })
    },
  )

  await t.test(
    'less than comparator with number (unquoted)',
    async t => {
      const res = await malware(getState(':malware(<2)'))
      t.strictSame(
        [...res.partial.nodes].map(n => n.name).sort(),
        ['a', 'b', 'e', 'f'],
        'should select packages with malware kind less than 2',
      )
      t.matchSnapshot({
        nodes: [...res.partial.nodes].map(n => n.name).sort(),
        edges: [...res.partial.edges].map(e => e.name).sort(),
      })
    },
  )

  await t.test(
    'less than comparator with string kind (quoted)',
    async t => {
      const res = await malware(getState(':malware("<medium")'))
      t.strictSame(
        [...res.partial.nodes].map(n => n.name).sort(),
        ['a', 'b', 'e', 'f'],
        'should select packages with malware kind less than medium',
      )
      t.matchSnapshot({
        nodes: [...res.partial.nodes].map(n => n.name).sort(),
        edges: [...res.partial.edges].map(e => e.name).sort(),
      })
    },
  )

  await t.test(
    'greater than or equal to comparator with number (unquoted)',
    async t => {
      const res = await malware(getState(':malware(>=2)'))
      t.strictSame(
        [...res.partial.nodes].map(n => n.name).sort(),
        ['c', 'd'],
        'should select packages with malware kind greater than or equal to 2',
      )
      t.matchSnapshot({
        nodes: [...res.partial.nodes].map(n => n.name).sort(),
        edges: [...res.partial.edges].map(e => e.name).sort(),
      })
    },
  )

  await t.test(
    'greater than or equal to comparator with string kind (quoted)',
    async t => {
      const res = await malware(getState(':malware(">=medium")'))
      t.strictSame(
        [...res.partial.nodes].map(n => n.name).sort(),
        ['c', 'd'],
        'should select packages with malware kind greater than or equal to medium',
      )
      t.matchSnapshot({
        nodes: [...res.partial.nodes].map(n => n.name).sort(),
        edges: [...res.partial.edges].map(e => e.name).sort(),
      })
    },
  )

  await t.test(
    'less than or equal to comparator with number (unquoted)',
    async t => {
      const res = await malware(getState(':malware(<=1)'))
      t.strictSame(
        [...res.partial.nodes].map(n => n.name).sort(),
        ['a', 'b', 'e', 'f'],
        'should select packages with malware kind less than or equal to 1',
      )
      t.matchSnapshot({
        nodes: [...res.partial.nodes].map(n => n.name).sort(),
        edges: [...res.partial.edges].map(e => e.name).sort(),
      })
    },
  )

  await t.test(
    'less than or equal to comparator with string kind (quoted)',
    async t => {
      const res = await malware(getState(':malware("<=high")'))
      t.strictSame(
        [...res.partial.nodes].map(n => n.name).sort(),
        ['a', 'b', 'e', 'f'],
        'should select packages with malware kind less than or equal to high',
      )
      t.matchSnapshot({
        nodes: [...res.partial.nodes].map(n => n.name).sort(),
        edges: [...res.partial.edges].map(e => e.name).sort(),
      })
    },
  )

  await t.test('wrong parameter', async t => {
    await t.rejects(
      malware(getState(':malware')),
      { message: /Failed to parse :malware selector/ },
      'should throw an error',
    )
  })

  await t.test('invalid comparison value', async t => {
    await t.rejects(
      malware(getState(':malware(>invalid)')),
      { message: /Failed to parse :malware selector/ },
      'should throw an error for invalid comparison value',
    )
  })

  await t.test('out of range number', async t => {
    await t.rejects(
      malware(getState(':malware(>5)')),
      { message: /Failed to parse :malware selector/ },
      'should throw an error for out of range number',
    )
  })
})

t.test('missing security archive', async t => {
  const getState = (query: string) => {
    const ast = parse(query)
    const current = ast.first.first
    const state: ParserState = {
      current,
      initial: {
        edges: new Set(),
        nodes: new Set(),
      },
      partial: {
        edges: new Set(),
        nodes: new Set(),
      },
      collect: {
        edges: new Set(),
        nodes: new Set(),
      },
      cancellable: async () => {},
      walk: async i => i,
      securityArchive: undefined,
      specOptions: {},
      retries: 0,
      signal: new AbortController().signal,
    }
    return state
  }

  await t.rejects(
    malware(getState(':malware(critical)')),
    { message: /Missing security archive/ },
    'should throw an error',
  )
})

t.test('isMalwareKind', async t => {
  t.ok(
    isMalwareKind('critical'),
    'should return true for valid malware kinds',
  )
  t.notOk(
    isMalwareKind('invalid'),
    'should return false for invalid malware kinds',
  )
})

t.test('asMalwareKind', async t => {
  t.equal(
    asMalwareKind('critical'),
    'critical',
    'should return the malware kind',
  )
  t.throws(
    () => asMalwareKind('invalid'),
    { message: /Expected a valid malware kind/ },
    'should throw an error for invalid malware kinds',
  )
})

t.test('parseInternals', async t => {
  const testParseInternals = (query: string) => {
    const ast = parse(query)
    const nodes = asPostcssNodeWithChildren(ast.first.first).nodes
    return parseInternals(nodes)
  }

  t.strictSame(
    testParseInternals(':malware(critical)'),
    { kind: 'critical', comparator: undefined },
    'should parse simple kind without comparator',
  )

  t.strictSame(
    testParseInternals(':malware(">1")'),
    { kind: '1', comparator: '>' },
    'should parse kind with greater than comparator',
  )

  t.strictSame(
    testParseInternals(':malware(<low)'),
    { kind: 'low', comparator: '<' },
    'should parse kind with less than comparator',
  )

  t.strictSame(
    testParseInternals(':malware(">=medium")'),
    { kind: 'medium', comparator: '>=' },
    'should parse kind with greater than or equal comparator',
  )

  t.strictSame(
    testParseInternals(':malware(<=2)'),
    { kind: '2', comparator: '<=' },
    'should parse kind with less than or equal comparator',
  )

  t.throws(
    () => testParseInternals(':malware(>invalid)'),
    {
      message: /Expected a valid malware kind or number between 0-3/,
    },
    'should throw for invalid kind with comparator',
  )

  t.throws(
    () => testParseInternals(':malware(>4)'),
    {
      message: /Expected a valid malware kind or number between 0-3/,
    },
    'should throw for out of range number with comparator',
  )
})
